Foundations_And_Core_Concepts/
â”œâ”€â”€ SQL_Basics/
â”‚   â”œâ”€â”€ What_is_SQL/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       SQL (**Structured Query Language**) is a **declarative language** designed to manage and manipulate relational databases.
â”‚   â”‚
â”‚   â”‚       ðŸ”¹ **Key Characteristics:**
â”‚   â”‚       - **Declarative:** You specify *what* data you want, not *how* to retrieve it.
â”‚   â”‚       - Operates on **sets of data**, not row-by-row imperative logic.
â”‚   â”‚       - Standardized by ANSI, with variations across RDBMS vendors.
â”‚   â”‚
â”‚   â”‚       ðŸ”¹ **Core SQL Categories:**
â”‚   â”‚       - **DDL (Data Definition Language):** `CREATE`, `ALTER`, `DROP` (Defines schema)
â”‚   â”‚       - **DML (Data Manipulation Language):** `SELECT`, `INSERT`, `UPDATE`, `DELETE`
â”‚   â”‚       - **DCL (Data Control Language):** `GRANT`, `REVOKE`
â”‚   â”‚       - **TCL (Transaction Control Language):** `COMMIT`, `ROLLBACK`
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       Example Query:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, salary 
â”‚   â”‚       FROM employees 
â”‚   â”‚       WHERE department = 'HR' AND salary > 50000;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       This retrieves employees in HR earning above 50,000.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Why SQL Matters:**
â”‚   â”‚       - Foundation for all relational database interactions.
â”‚   â”‚       - Powers backend systems, reporting tools, and data analytics pipelines.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       **Visualization of SQL Flow:**
â”‚   â”‚       ```
â”‚   â”‚       [Table: employees]
â”‚   â”‚       +----+--------+-------------+--------+
â”‚   â”‚       | ID | Name   | Department  | Salary |
â”‚   â”‚       +----+--------+-------------+--------+
â”‚   â”‚       | 1  | Alice  | HR          | 60000  |
â”‚   â”‚       | 2  | Bob    | IT          | 55000  |
â”‚   â”‚       | 3  | Carol  | HR          | 48000  |
â”‚   â”‚       | 4  | David  | HR          | 70000  |
â”‚   â”‚       +----+--------+-------------+--------+
â”‚   â”‚
â”‚   â”‚       Query Filter:
â”‚   â”‚       WHERE department = 'HR' AND salary > 50000
â”‚   â”‚
â”‚   â”‚       Result:
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | Name   | Salary |
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | Alice  | 60000  |
â”‚   â”‚       | David  | 70000  |
â”‚   â”‚       +--------+--------+
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       **Best Practices:**
â”‚   â”‚       - Always use **WHERE** clauses to avoid full table scans.
â”‚   â”‚       - Use **LIMIT** for large datasets during testing.
â”‚   â”‚       - Format queries for readability, especially joins and subqueries.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ SQL_vs_MySQL_vs_RDBMS/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **SQL**:
â”‚   â”‚       - A **language standard** (Structured Query Language) used to interact with relational databases.
â”‚   â”‚       - Defined by ANSI/ISO, implemented by various database systems.
â”‚   â”‚       - Think of SQL like "English grammar" â€” many people speak it, but with dialects.
â”‚   â”‚
â”‚   â”‚       ðŸ”¹ **MySQL**:
â”‚   â”‚       - A popular **Relational Database Management System (RDBMS)**.
â”‚   â”‚       - Uses SQL as its query language.
â”‚   â”‚       - Open-source (owned by Oracle now), widely used for web applications.
â”‚   â”‚       - Has its own **extensions** to standard SQL (like `LIMIT` keyword).
â”‚   â”‚
â”‚   â”‚       ðŸ”¹ **Other RDBMS**:
â”‚   â”‚       | Feature             | MySQL     | PostgreSQL | OracleDB   | SQL Server |
â”‚   â”‚       |---------------------|-----------|------------|------------|------------|
â”‚   â”‚       | Open Source         | Yes       | Yes        | No         | No         |
â”‚   â”‚       | ACID Compliance     | Good      | Excellent  | Excellent  | Excellent  |
â”‚   â”‚       | JSON Support        | Moderate  | Advanced   | Advanced   | Good       |
â”‚   â”‚       | Best for            | Web Apps  | Complex Queries | Enterprise | Windows Ecosystem |
â”‚   â”‚       | Procedural Language | SQL/PSM   | PL/pgSQL   | PL/SQL     | T-SQL      |
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Key Differences:**
â”‚   â”‚       - **SQL** = Language.
â”‚   â”‚       - **MySQL/PostgreSQL/Oracle** = Software systems that *implement* SQL.
â”‚   â”‚       - Each RDBMS has:
â”‚   â”‚         - Different storage engines.
â”‚   â”‚         - Varying support for advanced features (e.g., partitioning, window functions).
â”‚   â”‚         - Proprietary functions/extensions.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Stick to **ANSI SQL** standards when aiming for portability across databases.
â”‚   â”‚       - Leverage RDBMS-specific features when optimizing for a single platform.
â”‚   â”‚       - For MySQL, understand storage engines (e.g., **InnoDB** vs **MyISAM**).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Common Pitfall:**
â”‚   â”‚       Queries written for MySQL might fail in PostgreSQL due to syntax differences like:
â”‚   â”‚       ```sql
â”‚   â”‚       -- MySQL-specific
â”‚   â”‚       SELECT * FROM employees LIMIT 5 OFFSET 10;
â”‚   â”‚
â”‚   â”‚       -- SQL Server equivalent
â”‚   â”‚       SELECT * FROM employees ORDER BY id OFFSET 10 ROWS FETCH NEXT 5 ROWS ONLY;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ Data_Types_In_MySQL/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       Data types define **what kind of data** can be stored in each column.
â”‚   â”‚       Choosing the right type impacts:
â”‚   â”‚       - **Storage efficiency**
â”‚   â”‚       - **Query performance**
â”‚   â”‚       - **Data integrity**
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Main Categories:**
â”‚   â”‚       1. **Numeric Types**
â”‚   â”‚          - `TINYINT` (1 byte), `SMALLINT`, `INT` (4 bytes), `BIGINT` (8 bytes)
â”‚   â”‚          - `DECIMAL(p,s)` for exact precision (financial data)
â”‚   â”‚          - `FLOAT`, `DOUBLE` for approximate values
â”‚   â”‚
â”‚   â”‚          Example:
â”‚   â”‚          ```sql
â”‚   â”‚          price DECIMAL(10,2)   -- Up to 99999999.99
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       2. **String Types**
â”‚   â”‚          - `CHAR(n)`: Fixed length
â”‚   â”‚          - `VARCHAR(n)`: Variable length
â”‚   â”‚          - `TEXT`, `BLOB`: Large texts/binary data
â”‚   â”‚
â”‚   â”‚          Example:
â”‚   â”‚          ```sql
â”‚   â”‚          name VARCHAR(50)
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       3. **Date and Time Types**
â”‚   â”‚          - `DATE` (YYYY-MM-DD)
â”‚   â”‚          - `DATETIME`, `TIMESTAMP` (timezone-aware)
â”‚   â”‚          - `TIME`, `YEAR`
â”‚   â”‚
â”‚   â”‚          Example:
â”‚   â”‚          ```sql
â”‚   â”‚          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization: Storage Impact**
â”‚   â”‚       | Data Type    | Storage   | Notes                       |
â”‚   â”‚       |--------------|-----------|-----------------------------|
â”‚   â”‚       | INT          | 4 Bytes   | -2B to +2B                  |
â”‚   â”‚       | VARCHAR(100) | Varies    | Actual length + 1 or 2 bytes|
â”‚   â”‚       | DATE         | 3 Bytes   | '1000-01-01' to '9999-12-31'|
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use the **smallest numeric type** that fits your data range.
â”‚   â”‚       - Prefer `VARCHAR` over `TEXT` for searchable columns.
â”‚   â”‚       - Use `DECIMAL` for monetary valuesâ€”**never FLOAT** due to precision errors.
â”‚   â”‚       - Always define appropriate lengths (`VARCHAR(255)` is **not** a default!).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Common Pitfalls:**
â”‚   â”‚       - Oversizing fields â†’ wasted storage & slower indexes.
â”‚   â”‚       - Using `DATETIME` when `DATE` suffices.
â”‚   â”‚       - Forgetting that `TIMESTAMP` auto-converts to UTC.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Example Table Definition:**
â”‚   â”‚       ```sql
â”‚   â”‚       CREATE TABLE orders (
â”‚   â”‚           order_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
â”‚   â”‚           customer_name VARCHAR(100) NOT NULL,
â”‚   â”‚           order_total DECIMAL(10,2),
â”‚   â”‚           order_date DATE
â”‚   â”‚       );
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ NULL_Handling/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **What is NULL?**
â”‚   â”‚       - `NULL` represents **unknown**, **missing**, or **inapplicable** data.
â”‚   â”‚       - It is **NOT**:
â”‚   â”‚         - Zero (`0`)
â”‚   â”‚         - An empty string (`''`)
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Behavior of NULL in SQL:**
â”‚   â”‚       1. **Comparisons Involving NULL:**
â”‚   â”‚          - `NULL = NULL` â†’ **Unknown (NULL)**
â”‚   â”‚          - Use `IS NULL` or `IS NOT NULL` for checks.
â”‚   â”‚
â”‚   â”‚          Example:
â”‚   â”‚          ```sql
â”‚   â”‚          SELECT * FROM employees WHERE manager_id IS NULL;
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       2. **NULL in Expressions:**
â”‚   â”‚          - Any arithmetic or string operation with `NULL` results in `NULL`.
â”‚   â”‚          ```sql
â”‚   â”‚          SELECT salary + NULL  --> NULL
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       3. **Aggregations & NULL:**
â”‚   â”‚          - Functions like `AVG()`, `SUM()`, `COUNT(column)` **ignore NULLs**.
â”‚   â”‚          - But `COUNT(*)` counts all rows.
â”‚   â”‚
â”‚   â”‚          Example:
â”‚   â”‚          ```sql
â”‚   â”‚          SELECT AVG(bonus) FROM salaries;
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Handling NULLs:**
â”‚   â”‚       - Use `COALESCE()` to substitute default values.
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, COALESCE(bonus, 0) AS bonus FROM salaries;
â”‚   â”‚       ```
â”‚   â”‚       This replaces `NULL` bonuses with `0`.
â”‚   â”‚
â”‚   â”‚       - Alternative: `IFNULL()` in MySQL.
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT IFNULL(bonus, 0) FROM salaries;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Common Pitfalls:**
â”‚   â”‚       - Using `=` or `!=` with NULL:
â”‚   â”‚         ```sql
â”‚   â”‚         WHERE bonus = NULL    -- âŒ Incorrect
â”‚   â”‚         WHERE bonus IS NULL   -- âœ… Correct
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚       - Misunderstanding `NOT IN` with NULLs:
â”‚   â”‚         ```sql
â”‚   â”‚         WHERE dept_id NOT IN (1, 2, NULL)  -- Returns no rows!
â”‚   â”‚         ```
â”‚   â”‚         If `NULL` is present in an `IN` list, comparisons become unknown.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Define columns as `NOT NULL` wherever possible.
â”‚   â”‚       - Use default values to minimize unnecessary NULLs.
â”‚   â”‚       - Be explicit in handling NULL logic in queries.
â”‚   â”‚
â”‚   â”‚
â”‚   â””â”€â”€ Schema_Design_Basics/
â”‚       â””â”€â”€ Explanation:
â”‚           ðŸ”¹ **What is Schema Design?**
â”‚           Schema design is the process of structuring your databaseâ€”defining how data is organized, related, and constrained.
â”‚
â”‚           A well-designed schema ensures:
â”‚           - **Data Integrity**
â”‚           - **Performance Optimization**
â”‚           - **Scalability & Maintainability**
â”‚
â”‚           ---
â”‚           ðŸ“Œ **Key Principles:**
â”‚           1. **Normalization** (Eliminate Redundancy)
â”‚              - Apply normal forms (1NF, 2NF, 3NF) to avoid data anomalies.
â”‚              - Example of redundancy:
â”‚              ```
â”‚              Orders Table:
â”‚              +---------+------------+------------+
â”‚              | OrderID | Customer   | CustomerPhone |
â”‚              +---------+------------+------------+
â”‚              |   101   | Alice      | 1234567890   |
â”‚              |   102   | Alice      | 1234567890   |
â”‚              ```
â”‚              Solution: Split into `Customers` and `Orders`.
â”‚
â”‚           2. **Use Proper Data Types**
â”‚              - Optimize storage and enforce correct data formats.
â”‚
â”‚           3. **Define Keys & Relationships**
â”‚              - **Primary Keys**: Uniquely identify records.
â”‚              - **Foreign Keys**: Maintain referential integrity.
â”‚
â”‚           4. **Index Strategically**
â”‚              - Design indexes based on query patterns.
â”‚
â”‚           ---
â”‚           ðŸ”¹ **Example: Basic Schema Design**
â”‚           ```sql
â”‚           CREATE TABLE customers (
â”‚               customer_id INT PRIMARY KEY,
â”‚               name VARCHAR(100) NOT NULL
â”‚           );
â”‚
â”‚           CREATE TABLE orders (
â”‚               order_id INT PRIMARY KEY,
â”‚               customer_id INT,
â”‚               order_date DATE,
â”‚               FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
â”‚           );
â”‚           ```
â”‚
â”‚           ---
â”‚           ðŸš¨ **Common Pitfalls:**
â”‚           - **Over-Normalization** leading to excessive JOINs.
â”‚           - Forgetting to define **constraints**, allowing dirty data.
â”‚           - Using generic data types like `TEXT` or oversized `VARCHAR`.
â”‚
â”‚           ---
â”‚           âœ… **Best Practices:**
â”‚           - Balance **Normalization vs. Performance** (Denormalize where necessary for read-heavy systems).
â”‚           - Always define **Primary Keys**.
â”‚           - Use **naming conventions** for clarity (e.g., `user_id`, `order_id`).
â”‚           - Anticipate growth: avoid hard limits unless justified.
â”‚
â”‚           ---
â”‚           ðŸ“Š **Visualization of Relationships (ERD Concept):**
â”‚           ```
â”‚           customers
â”‚           +-------------+
â”‚           | customer_id |â—„â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           | name        |         â”‚
â”‚           +-------------+         â”‚
â”‚                                   â”‚
â”‚           orders                  â”‚
â”‚           +----------+-------------+
â”‚           | order_id | customer_id â”‚
â”‚           | date     |             â”‚
â”‚           +----------+-------------+
â”‚           ```
â”‚
â”‚
â”œâ”€â”€ Database_Objects/
â”‚   â”œâ”€â”€ Tables/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **What is a Table?**
â”‚   â”‚       - A **Table** is the fundamental storage unit in a relational database.
â”‚   â”‚       - It organizes data into **rows** (records) and **columns** (attributes).
â”‚   â”‚       - Each column has a defined **data type**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Table Structure Example:**
â”‚   â”‚       ```sql
â”‚   â”‚       CREATE TABLE employees (
â”‚   â”‚           emp_id INT PRIMARY KEY,
â”‚   â”‚           name VARCHAR(100) NOT NULL,
â”‚   â”‚           department VARCHAR(50),
â”‚   â”‚           hire_date DATE,
â”‚   â”‚           salary DECIMAL(10,2)
â”‚   â”‚       );
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       This defines:
â”‚   â”‚       - `emp_id` as a unique identifier.
â”‚   â”‚       - `name` must always have a value (`NOT NULL`).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization:**
â”‚   â”‚       employees
â”‚   â”‚       +--------+---------+------------+------------+---------+
â”‚   â”‚       | emp_id | name    | department | hire_date  | salary  |
â”‚   â”‚       +--------+---------+------------+------------+---------+
â”‚   â”‚       |   1    | Alice   | HR         | 2022-01-15 | 60000.00|
â”‚   â”‚       |   2    | Bob     | IT         | 2021-11-20 | 55000.00|
â”‚   â”‚       +--------+---------+------------+------------+---------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Key Operations:**
â”‚   â”‚       - `INSERT INTO`, `SELECT`, `UPDATE`, `DELETE`.
â”‚   â”‚       - Example Insert:
â”‚   â”‚         ```sql
â”‚   â”‚         INSERT INTO employees (emp_id, name, department, hire_date, salary)
â”‚   â”‚         VALUES (3, 'Carol', 'Finance', '2023-03-10', 70000);
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Common Pitfalls:**
â”‚   â”‚       - No Primary Key defined â†’ Leads to duplicate or unidentifiable rows.
â”‚   â”‚       - Poor choice of data types causing storage bloat.
â”‚   â”‚       - Lack of constraints leading to inconsistent data.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Always define a **Primary Key**.
â”‚   â”‚       - Use **appropriate data types** and avoid defaults like `VARCHAR(255)` blindly.
â”‚   â”‚       - Add constraints to enforce business rules.
â”‚   â”‚       - Use **AUTO_INCREMENT** for surrogate keys when natural keys aren't available.
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       CREATE TABLE products (
â”‚   â”‚           product_id INT AUTO_INCREMENT PRIMARY KEY,
â”‚   â”‚           product_name VARCHAR(100) NOT NULL
â”‚   â”‚       );
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ Views/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **What is a View?**
â”‚   â”‚       - A **View** is a **virtual table** based on a SQL query.
â”‚   â”‚       - It doesn't store data physically but presents data dynamically from underlying tables.
â”‚   â”‚       - Useful for:
â”‚   â”‚         - Simplifying complex queries.
â”‚   â”‚         - Enhancing security (restricting column/row access).
â”‚   â”‚         - Providing abstraction layers.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Creating a View:**
â”‚   â”‚       ```sql
â”‚   â”‚       CREATE VIEW active_employees AS
â”‚   â”‚       SELECT emp_id, name, department
â”‚   â”‚       FROM employees
â”‚   â”‚       WHERE status = 'active';
â”‚   â”‚       ```
â”‚   â”‚       - Querying the View:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT * FROM active_employees;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Types of Views:**
â”‚   â”‚       1. **Simple Views** â€“ Based on a single table without functions or GROUP BY.
â”‚   â”‚       2. **Complex Views** â€“ Involve joins, aggregations, functions.
â”‚   â”‚       3. **Updatable Views** â€“ Some views allow `INSERT`, `UPDATE`, `DELETE`.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Limitations:**
â”‚   â”‚       - Views canâ€™t always be updated, especially if:
â”‚   â”‚         - They use `GROUP BY`, `DISTINCT`, `UNION`.
â”‚   â”‚         - They include aggregate functions.
â”‚   â”‚       - Performance: Each query on a view runs the underlying SQL â†’ No "free" optimization unless using **Materialized Views** (not natively in MySQL).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use Views to **encapsulate business logic**.
â”‚   â”‚       - Restrict user access to base tables by granting permissions on Views.
â”‚   â”‚       - Avoid nesting Views within Views in critical paths (can cause performance hits).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Example: Join Simplification via View**
â”‚   â”‚       ```sql
â”‚   â”‚       CREATE VIEW order_summary AS
â”‚   â”‚       SELECT o.order_id, c.name AS customer_name, o.order_total
â”‚   â”‚       FROM orders o
â”‚   â”‚       JOIN customers c ON o.customer_id = c.customer_id;
â”‚   â”‚       ```
â”‚   â”‚       Now, users can:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT * FROM order_summary WHERE order_total > 500;
â”‚   â”‚       ```
â”‚   â”‚       Without knowing the join logic.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ Indexes/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **What is an Index?**
â”‚   â”‚       - An **Index** is a data structure (typically a **B-Tree** in MySQL) that improves the speed of data retrieval.
â”‚   â”‚       - Think of it like a bookâ€™s index â€” it helps you find information without scanning every page.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Types of Indexes in MySQL:**
â”‚   â”‚       1. **Primary Index**:
â”‚   â”‚          - Automatically created on the **Primary Key**.
â”‚   â”‚          - In InnoDB, this is a **Clustered Index**.
â”‚   â”‚
â”‚   â”‚       2. **Secondary (Non-Clustered) Index**:
â”‚   â”‚          - Created on other columns.
â”‚   â”‚          ```sql
â”‚   â”‚          CREATE INDEX idx_name ON employees(name);
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       3. **Unique Index**:
â”‚   â”‚          - Ensures all values are unique.
â”‚   â”‚          ```sql
â”‚   â”‚          CREATE UNIQUE INDEX idx_email ON users(email);
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       4. **Composite Index**:
â”‚   â”‚          - Index on multiple columns.
â”‚   â”‚          ```sql
â”‚   â”‚          CREATE INDEX idx_dept_salary ON employees(department, salary);
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       5. **Full-Text Index** (For text search)
â”‚   â”‚
â”‚   â”‚       6. **Spatial Index** (For GIS data)
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization: How an Index Works**
â”‚   â”‚       Without Index:
â”‚   â”‚       ```
â”‚   â”‚       SELECT * FROM employees WHERE name = 'Alice';
â”‚   â”‚       -- Full Table Scan (O(n))
â”‚   â”‚       ```
â”‚   â”‚       With Index on `name`:
â”‚   â”‚       ```
â”‚   â”‚       -- B-Tree traversal (O(log n))
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Trade-offs:**
â”‚   â”‚       - **Pros**: Speeds up `SELECT`, `WHERE`, `JOIN`, `ORDER BY`.
â”‚   â”‚       - **Cons**: Slows down `INSERT`, `UPDATE`, `DELETE` due to index maintenance.
â”‚   â”‚       - Consumes extra disk space.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Index columns used frequently in:
â”‚   â”‚         - `WHERE` clauses.
â”‚   â”‚         - `JOIN` conditions.
â”‚   â”‚         - `ORDER BY` / `GROUP BY`.
â”‚   â”‚
â”‚   â”‚       - Use **Composite Indexes** wisely â€” order matters!
â”‚   â”‚         - Index `(col1, col2)` supports queries filtering on `col1` or `col1 AND col2`.
â”‚   â”‚         - But **not** on `col2` alone.
â”‚   â”‚
â”‚   â”‚       - Avoid indexing:
â”‚   â”‚         - Columns with low cardinality (e.g., gender).
â”‚   â”‚         - Frequently updated columns.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Example:**
â”‚   â”‚       ```sql
â”‚   â”‚       CREATE INDEX idx_order_date ON orders(order_date);
â”‚   â”‚
â”‚   â”‚       -- Optimized query
â”‚   â”‚       SELECT * FROM orders WHERE order_date >= '2024-01-01';
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ Stored_Procedures/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **What is a Stored Procedure?**
â”‚   â”‚       - A **Stored Procedure** is a precompiled set of SQL statements stored in the database.
â”‚   â”‚       - It allows you to execute complex operations by calling a single procedure.
â”‚   â”‚       - Promotes **code reuse**, **centralized logic**, and **security**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Creating a Stored Procedure:**
â”‚   â”‚       ```sql
â”‚   â”‚       DELIMITER //
â”‚   â”‚       CREATE PROCEDURE GetHighEarners(IN min_salary DECIMAL(10,2))
â”‚   â”‚       BEGIN
â”‚   â”‚           SELECT name, salary FROM employees WHERE salary > min_salary;
â”‚   â”‚       END //
â”‚   â”‚       DELIMITER ;
â”‚   â”‚       ```
â”‚   â”‚       - **Call it**:
â”‚   â”‚       ```sql
â”‚   â”‚       CALL GetHighEarners(60000);
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Parameters:**
â”‚   â”‚       - `IN`  â†’ Input parameter.
â”‚   â”‚       - `OUT` â†’ Output parameter.
â”‚   â”‚       - `INOUT` â†’ Acts as both input and output.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Common Use Cases:**
â”‚   â”‚       - Batch operations.
â”‚   â”‚       - Data validation routines.
â”‚   â”‚       - Complex business logic.
â”‚   â”‚       - Abstracting repetitive queries from applications.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Considerations:**
â”‚   â”‚       - Reduces **network traffic** by bundling operations.
â”‚   â”‚       - BUT, procedural code in SQL (loops, conditionals) can be slower than app-level logic.
â”‚   â”‚       - Harder to scale in distributed architectures (logic locked in DB).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use for **data-centric operations** (where data is heavily involved).
â”‚   â”‚       - Avoid embedding heavy business logicâ€”keep that in application layers.
â”‚   â”‚       - Document procedures well; they can become hidden "black boxes".
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Example with OUT parameter:**
â”‚   â”‚       ```sql
â”‚   â”‚       DELIMITER //
â”‚   â”‚       CREATE PROCEDURE CountEmployees(OUT emp_count INT)
â”‚   â”‚       BEGIN
â”‚   â”‚           SELECT COUNT(*) INTO emp_count FROM employees;
â”‚   â”‚       END //
â”‚   â”‚       DELIMITER ;
â”‚   â”‚
â”‚   â”‚       CALL CountEmployees(@total);
â”‚   â”‚       SELECT @total;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚
â”‚   â””â”€â”€ Constraints/
â”‚       â”œâ”€â”€ Primary_Key/
â”‚       â”‚   â””â”€â”€ Explanation:
â”‚       â”‚       - A **Primary Key (PK)** uniquely identifies each row in a table.
â”‚       â”‚       - It is **NOT NULL** and **UNIQUE** by definition.
â”‚       â”‚       - A table can have **only one** PK (can be single or multi-column).
â”‚       â”‚
â”‚       â”‚       Example (Single-column PK):
â”‚       â”‚       ```sql
â”‚       â”‚       CREATE TABLE customers (
â”‚       â”‚           customer_id INT PRIMARY KEY,
â”‚       â”‚           name VARCHAR(100)
â”‚       â”‚       );
â”‚       â”‚       ```
â”‚       â”‚
â”‚       â”‚       Example (Composite PK):
â”‚       â”‚       ```sql
â”‚       â”‚       CREATE TABLE enrollments (
â”‚       â”‚           student_id INT,
â”‚       â”‚           course_id INT,
â”‚       â”‚           PRIMARY KEY (student_id, course_id)
â”‚       â”‚       );
â”‚       â”‚       ```
â”‚       â”‚
â”‚       â”‚       âœ… **Best Practices:**
â”‚       â”‚       - Use **surrogate keys** (`AUTO_INCREMENT`) when natural keys are too complex.
â”‚       â”‚       - Keep composite keys minimal to avoid large index overhead.
â”‚       â”‚
â”‚       â”œâ”€â”€ Foreign_Key/
â”‚       â”‚   â””â”€â”€ Explanation:
â”‚       â”‚       - A **Foreign Key (FK)** enforces referential integrity between tables.
â”‚       â”‚       - Links a column in one table to the **Primary Key** in another.
â”‚       â”‚
â”‚       â”‚       Example:
â”‚       â”‚       ```sql
â”‚       â”‚       CREATE TABLE orders (
â”‚       â”‚           order_id INT PRIMARY KEY,
â”‚       â”‚           customer_id INT,
â”‚       â”‚           FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
â”‚       â”‚       );
â”‚       â”‚       ```
â”‚       â”‚
â”‚       â”‚       ðŸ”¹ **Cascading Actions**:
â”‚       â”‚       ```sql
â”‚       â”‚       FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
â”‚       â”‚       ON DELETE CASCADE
â”‚       â”‚       ON UPDATE CASCADE
â”‚       â”‚       ```
â”‚       â”‚       - `CASCADE`: Propagates changes.
â”‚       â”‚       - `SET NULL`: Sets FK to NULL.
â”‚       â”‚       - `RESTRICT` / `NO ACTION`: Prevents the change.
â”‚       â”‚
â”‚       â”‚       ðŸš¨ **Pitfall:** Be cautious with `ON DELETE CASCADE` in production systems!
â”‚       â”‚
â”‚       â”œâ”€â”€ Unique/
â”‚       â”‚   â””â”€â”€ Explanation:
â”‚       â”‚       - Ensures all values in a column (or group of columns) are **unique**.
â”‚       â”‚       - Unlike PK, allows **multiple NULLs**.
â”‚       â”‚
â”‚       â”‚       Example:
â”‚       â”‚       ```sql
â”‚       â”‚       CREATE TABLE users (
â”‚       â”‚           user_id INT PRIMARY KEY,
â”‚       â”‚           email VARCHAR(100),
â”‚       â”‚           UNIQUE (email)
â”‚       â”‚       );
â”‚       â”‚       ```
â”‚       â”‚
â”‚       â”‚       ðŸ”¹ Composite UNIQUE:
â”‚       â”‚       ```sql
â”‚       â”‚       UNIQUE (first_name, last_name)
â”‚       â”‚       ```
â”‚       â”‚
â”‚       â”œâ”€â”€ Check/
â”‚       â”‚   â””â”€â”€ Explanation:
â”‚       â”‚       - Restricts values based on a condition.
â”‚       â”‚       - Enforced at the row level during `INSERT` or `UPDATE`.
â”‚       â”‚
â”‚       â”‚       Example:
â”‚       â”‚       ```sql
â”‚       â”‚       CREATE TABLE employees (
â”‚       â”‚           emp_id INT PRIMARY KEY,
â”‚       â”‚           salary DECIMAL(10,2),
â”‚       â”‚           CHECK (salary >= 15000)
â”‚       â”‚       );
â”‚       â”‚       ```
â”‚       â”‚
â”‚       â”‚       ðŸ”¹ Advanced Example:
â”‚       â”‚       ```sql
â”‚       â”‚       CHECK (end_date > start_date)
â”‚       â”‚       ```
â”‚       â”‚
â”‚       â”‚       ðŸš¨ Note: MySQL enforced `CHECK` constraints only from version 8.0+.
â”‚       â”‚
â”‚       â””â”€â”€ Default/
â”‚           â””â”€â”€ Explanation:
â”‚               - Sets a **default value** when no explicit value is provided.
â”‚
â”‚               Example:
â”‚               ```sql
â”‚               CREATE TABLE products (
â”‚                   product_id INT PRIMARY KEY,
â”‚                   stock INT DEFAULT 0
â”‚               );
â”‚
â”‚               INSERT INTO products (product_id) VALUES (1);
â”‚               -- stock will be 0 by default
â”‚               ```
â”‚
â”‚               âœ… Best Practices:
â”‚               - Use defaults to avoid NULLs where applicable.
â”‚               - For timestamps:
â”‚               ```sql
â”‚               created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
â”‚               ```
â”‚
â”‚
â”œâ”€â”€ SELECT_Statement/
â”‚   â”œâ”€â”€ Basic_SELECT/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Retrieve data from one or more tables.
â”‚   â”‚       - The `SELECT` statement defines **which columns** to fetch.
â”‚   â”‚       - By default, it returns **all matching rows** unless filtered.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT column1, column2, ...
â”‚   â”‚       FROM table_name;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, department FROM employees;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       - Use `SELECT *` to fetch **all columns**, but:
â”‚   â”‚         ðŸš¨ **Avoid `SELECT *` in production** â€” itâ€™s inefficient and can break apps if schema changes.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       Table: employees
â”‚   â”‚       +----+--------+------------+--------+
â”‚   â”‚       | id | name   | department | salary |
â”‚   â”‚       +----+--------+------------+--------+
â”‚   â”‚       | 1  | Alice  | HR         | 60000  |
â”‚   â”‚       | 2  | Bob    | IT         | 55000  |
â”‚   â”‚       +----+--------+------------+--------+
â”‚   â”‚
â”‚   â”‚       Query:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, salary FROM employees;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       Result:
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | name   | salary |
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | Alice  | 60000  |
â”‚   â”‚       | Bob    | 55000  |
â”‚   â”‚       +--------+--------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Always specify required columns.
â”‚   â”‚       - Alias columns for clarity:
â”‚   â”‚         ```sql
â”‚   â”‚         SELECT name AS employee_name FROM employees;
â”‚   â”‚         ```
â”‚   â”‚       - Use consistent formatting for readability.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Common Pitfalls:**
â”‚   â”‚       - Forgetting the `FROM` clause (applies in some DBs, but not standard SQL).
â”‚   â”‚       - Using `SELECT *` leading to:
â”‚   â”‚         - Increased network load.
â”‚   â”‚         - Unused data fetched.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ SELECT_DISTINCT/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Eliminate **duplicate rows** from the result set.
â”‚   â”‚       - `DISTINCT` applies to **all selected columns** as a group.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT DISTINCT column1, column2
â”‚   â”‚       FROM table_name;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT DISTINCT department FROM employees;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       employees table:
â”‚   â”‚       +----+--------+------------+
â”‚   â”‚       | id | name   | department |
â”‚   â”‚       +----+--------+------------+
â”‚   â”‚       | 1  | Alice  | HR         |
â”‚   â”‚       | 2  | Bob    | IT         |
â”‚   â”‚       | 3  | Carol  | HR         |
â”‚   â”‚
â”‚   â”‚       Query:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT DISTINCT department FROM employees;
â”‚   â”‚       ```
â”‚   â”‚       Result:
â”‚   â”‚       +------------+
â”‚   â”‚       | department |
â”‚   â”‚       +------------+
â”‚   â”‚       | HR         |
â”‚   â”‚       | IT         |
â”‚   â”‚       +------------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - `DISTINCT` applies to the **combination** of columns:
â”‚   â”‚         ```sql
â”‚   â”‚         SELECT DISTINCT department, name FROM employees;
â”‚   â”‚         ```
â”‚   â”‚         This only removes rows where **both** columns are identical.
â”‚   â”‚
â”‚   â”‚       - Internally, MySQL performs a **sort** or uses a **temporary table** â†’ Can impact performance on large datasets.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Only use `DISTINCT` when truly needed â€” avoid as a lazy fix for bad joins or poor data modeling.
â”‚   â”‚       - For counting unique values:
â”‚   â”‚         ```sql
â”‚   â”‚         SELECT COUNT(DISTINCT department) FROM employees;
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Alternative Techniques:**
â”‚   â”‚       - Use `GROUP BY` when you also want aggregations.
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT department FROM employees GROUP BY department;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ SELECT_with_WHERE/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Filter rows based on specified conditions.
â”‚   â”‚       - The `WHERE` clause restricts the result set to rows that meet the condition(s).
â”‚   â”‚       - It operates **before** grouping, ordering, or limiting results.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT column1, column2
â”‚   â”‚       FROM table_name
â”‚   â”‚       WHERE condition;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, salary
â”‚   â”‚       FROM employees
â”‚   â”‚       WHERE department = 'IT' AND salary > 50000;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       employees table:
â”‚   â”‚       +----+--------+------------+--------+
â”‚   â”‚       | id | name   | department | salary |
â”‚   â”‚       +----+--------+------------+--------+
â”‚   â”‚       | 1  | Alice  | HR         | 60000  |
â”‚   â”‚       | 2  | Bob    | IT         | 55000  |
â”‚   â”‚       | 3  | Carol  | IT         | 48000  |
â”‚   â”‚
â”‚   â”‚       Query Result:
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | name   | salary |
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | Bob    | 55000  |
â”‚   â”‚       +--------+--------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - String comparisons are **case-insensitive** by default in MySQL (`latin1` / `utf8_general_ci` collations).
â”‚   â”‚       - Use quotes `'value'` for string literals.
â”‚   â”‚       - Combine conditions using `AND`, `OR`, `NOT`.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use indexed columns in `WHERE` for better performance.
â”‚   â”‚       - Watch out for:
â”‚   â”‚         ```sql
â”‚   â”‚         WHERE column = NULL   -- âŒ Incorrect
â”‚   â”‚         WHERE column IS NULL  -- âœ… Correct
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚       - Use parentheses to control logic flow:
â”‚   â”‚         ```sql
â”‚   â”‚         WHERE (dept = 'HR' OR dept = 'IT') AND salary > 50000
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Alternative Techniques:**
â”‚   â”‚       - Use `BETWEEN`, `IN`, `LIKE` for flexible filtering (covered in detail under `WHERE_Clauses/`).
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ SELECT_with_ORDER_BY/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Sort the result set by one or more columns.
â”‚   â”‚       - By default, `ORDER BY` sorts in **ascending (ASC)** order.
â”‚   â”‚       - You can specify **DESC** for descending order.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT column1, column2
â”‚   â”‚       FROM table_name
â”‚   â”‚       ORDER BY column1 [ASC|DESC], column2 [ASC|DESC];
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, salary
â”‚   â”‚       FROM employees
â”‚   â”‚       ORDER BY salary DESC;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       employees table:
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | name   | salary |
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | Alice  | 60000  |
â”‚   â”‚       | Bob    | 55000  |
â”‚   â”‚       | Carol  | 48000  |
â”‚   â”‚
â”‚   â”‚       After `ORDER BY salary DESC`:
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | name   | salary |
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | Alice  | 60000  |
â”‚   â”‚       | Bob    | 55000  |
â”‚   â”‚       | Carol  | 48000  |
â”‚   â”‚       +--------+--------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - You can order by:
â”‚   â”‚         - **Column names**
â”‚   â”‚         - **Column positions** (not recommended for clarity)
â”‚   â”‚         ```sql
â”‚   â”‚         ORDER BY 2 DESC  -- Sorts by second selected column
â”‚   â”‚         ```
â”‚   â”‚       - `NULL` values by default:
â”‚   â”‚         - In MySQL, `NULL` appears **first** in ASC, **last** in DESC.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Always be explicit with `ASC` or `DESC` for readability.
â”‚   â”‚       - Use `ORDER BY` **after** filtering (`WHERE`), but **before** `LIMIT`.
â”‚   â”‚       - For stable sorting, include secondary columns:
â”‚   â”‚         ```sql
â”‚   â”‚         ORDER BY salary DESC, name ASC
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tips:**
â”‚   â”‚       - Sorting is resource-intensiveâ€”use indexes to optimize `ORDER BY` where possible.
â”‚   â”‚       - Avoid `ORDER BY` on calculated fields without necessity.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ SELECT_with_LIMIT_and_OFFSET/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Restrict the number of rows returned by a query.
â”‚   â”‚       - `LIMIT` defines **how many rows** to return.
â”‚   â”‚       - `OFFSET` defines **where to start** returning rows (used for pagination).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT column1, column2
â”‚   â”‚       FROM table_name
â”‚   â”‚       ORDER BY column1
â”‚   â”‚       LIMIT number_of_rows OFFSET start_point;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ðŸ”¹ Shortcut Syntax:
â”‚   â”‚       ```sql
â”‚   â”‚       LIMIT start_point, number_of_rows
â”‚   â”‚       ```
â”‚   â”‚       Example (get 5 rows starting from 11th row):
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT * FROM employees
â”‚   â”‚       ORDER BY emp_id
â”‚   â”‚       LIMIT 10, 5;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       Assume ordered employee IDs:
â”‚   â”‚       +--------+
â”‚   â”‚       | emp_id |
â”‚   â”‚       +--------+
â”‚   â”‚       |   1    |
â”‚   â”‚       |   2    |
â”‚   â”‚       |  ...   |
â”‚   â”‚       |  10    |
â”‚   â”‚       |  11    |  â—„â”€â”€ Start here (OFFSET 10)
â”‚   â”‚       |  12    |
â”‚   â”‚       |  13    |
â”‚   â”‚       |  14    |
â”‚   â”‚       |  15    |
â”‚   â”‚       +--------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - `LIMIT` without `ORDER BY` returns **arbitrary rows** (no guaranteed order).
â”‚   â”‚       - `OFFSET` starts counting from **zero**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Always pair `LIMIT` with `ORDER BY` for predictable results.
â”‚   â”‚       - For large offsets (deep pagination), performance degradesâ€”consider "keyset pagination" as an alternative.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Example: Pagination Query**
â”‚   â”‚       ```sql
â”‚   â”‚       -- Page 2, 10 rows per page
â”‚   â”‚       SELECT * FROM products
â”‚   â”‚       ORDER BY product_id
â”‚   â”‚       LIMIT 10 OFFSET 10;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ SELECT_with_GROUP_BY_and_HAVING/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**:
â”‚   â”‚       - `GROUP BY` groups rows sharing a value into summary rows.
â”‚   â”‚       - Typically used with **aggregate functions** (`COUNT`, `SUM`, etc.).
â”‚   â”‚       - `HAVING` filters groups **after aggregation** (whereas `WHERE` filters rows **before grouping**).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT column1, AGG_FUNC(column2)
â”‚   â”‚       FROM table_name
â”‚   â”‚       WHERE condition
â”‚   â”‚       GROUP BY column1
â”‚   â”‚       HAVING aggregate_condition
â”‚   â”‚       ORDER BY column1;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT department, COUNT(*) AS emp_count
â”‚   â”‚       FROM employees
â”‚   â”‚       GROUP BY department
â”‚   â”‚       HAVING emp_count > 5;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       employees table:
â”‚   â”‚       +--------+------------+
â”‚   â”‚       | name   | department |
â”‚   â”‚       +--------+------------+
â”‚   â”‚       | Alice  | HR         |
â”‚   â”‚       | Bob    | IT         |
â”‚   â”‚       | Carol  | HR         |
â”‚   â”‚       | Dave   | IT         |
â”‚   â”‚       | Emma   | HR         |
â”‚   â”‚
â”‚   â”‚       After `GROUP BY department`:
â”‚   â”‚       +------------+-----------+
â”‚   â”‚       | department | emp_count |
â”‚   â”‚       +------------+-----------+
â”‚   â”‚       | HR         |     3     |
â”‚   â”‚       | IT         |     2     |
â”‚   â”‚       +------------+-----------+
â”‚   â”‚
â”‚   â”‚       Apply `HAVING emp_count > 2`:
â”‚   â”‚       +------------+-----------+
â”‚   â”‚       | HR         |     3     |
â”‚   â”‚       +------------+-----------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - Every non-aggregated column in `SELECT` **must appear** in `GROUP BY`.
â”‚   â”‚       - `HAVING` works **after** aggregation â€” donâ€™t confuse it with `WHERE`.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use `WHERE` to reduce dataset **before** grouping for better performance.
â”‚   â”‚       - Alias aggregated columns for readability (`AS` keyword).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Example: Filter Before and After**
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT department, AVG(salary) AS avg_sal
â”‚   â”‚       FROM employees
â”‚   â”‚       WHERE salary > 40000
â”‚   â”‚       GROUP BY department
â”‚   â”‚       HAVING avg_sal > 50000;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚
â”œâ”€â”€ WHERE_Clauses/
â”‚   â”œâ”€â”€ Operators/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Operators define conditions in `WHERE` clauses to filter data.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Common Operators in SQL:**
â”‚   â”‚       1. `=` : **Equals**
â”‚   â”‚          ```sql
â”‚   â”‚          WHERE department = 'IT'
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       2. `<>` or `!=` : **Not Equal**
â”‚   â”‚          ```sql
â”‚   â”‚          WHERE salary <> 50000
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       3. `BETWEEN ... AND ...` : **Range Filter (Inclusive)**
â”‚   â”‚          ```sql
â”‚   â”‚          WHERE salary BETWEEN 40000 AND 60000
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       4. `LIKE` : **Pattern Matching**
â”‚   â”‚          - `%` = any sequence of characters
â”‚   â”‚          - `_` = single character
â”‚   â”‚          ```sql
â”‚   â”‚          WHERE name LIKE 'A%'
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       5. `IN` : **Match from a List**
â”‚   â”‚          ```sql
â”‚   â”‚          WHERE department IN ('HR', 'IT')
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       6. `IS NULL` / `IS NOT NULL` : **Null Checks**
â”‚   â”‚          ```sql
â”‚   â”‚          WHERE manager_id IS NULL
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization Example**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT * FROM employees
â”‚   â”‚       WHERE salary BETWEEN 50000 AND 70000
â”‚   â”‚             AND department IN ('HR', 'Finance');
â”‚   â”‚       ```
â”‚   â”‚       - Filters employees in HR/Finance earning within the specified range.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - `BETWEEN` is **inclusive** (includes boundary values).
â”‚   â”‚       - `LIKE 'A%'` is **case-insensitive** by default in MySQL unless collation is changed.
â”‚   â”‚       - `IN` with a large list may degrade performance â€” consider using a join with a lookup table.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - For patterns, avoid starting `LIKE` with `%`:
â”‚   â”‚         ```sql
â”‚   â”‚         WHERE name LIKE '%son'   -- âŒ Prevents index usage
â”‚   â”‚         WHERE name LIKE 'A%'     -- âœ… Index-friendly
â”‚   â”‚         ```
â”‚   â”‚       - Use `IS NULL` properly â€” never use `= NULL`.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Alternative:**
â”‚   â”‚       - Replace multiple `OR` conditions with `IN` for cleaner syntax:
â”‚   â”‚         ```sql
â”‚   â”‚         WHERE dept = 'HR' OR dept = 'IT' OR dept = 'Finance'
â”‚   â”‚         -- becomes
â”‚   â”‚         WHERE dept IN ('HR', 'IT', 'Finance')
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ Logical_Operators/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Combine multiple conditions in a `WHERE` clause.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Logical Operators:**
â”‚   â”‚       1. **`AND`** â€” All conditions must be true.
â”‚   â”‚          ```sql
â”‚   â”‚          WHERE department = 'IT' AND salary > 50000
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       2. **`OR`** â€” At least one condition must be true.
â”‚   â”‚          ```sql
â”‚   â”‚          WHERE department = 'HR' OR department = 'Finance'
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       3. **`NOT`** â€” Negates a condition.
â”‚   â”‚          ```sql
â”‚   â”‚          WHERE NOT (department = 'HR')
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization of Condition Logic**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT * FROM employees
â”‚   â”‚       WHERE department = 'IT'
â”‚   â”‚         AND salary BETWEEN 50000 AND 70000
â”‚   â”‚         OR department = 'HR';
â”‚   â”‚       ```
â”‚   â”‚       âš ï¸ Without parentheses, this evaluates as:
â”‚   â”‚       ```
â”‚   â”‚       (department = 'IT' AND salary BETWEEN 50k AND 70k)
â”‚   â”‚       OR
â”‚   â”‚       (department = 'HR')
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - `AND` has **higher precedence** than `OR`.
â”‚   â”‚       - Always use **parentheses** `()` to make logic explicit and avoid surprises.
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       WHERE (department = 'IT' OR department = 'HR')
â”‚   â”‚         AND salary > 50000
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use parentheses to clarify complex conditions.
â”‚   â”‚       - Avoid overusing `NOT` â€” it can confuse logic and sometimes block index usage.
â”‚   â”‚       - Rewrite negative logic where possible:
â”‚   â”‚         ```sql
â”‚   â”‚         WHERE NOT (salary BETWEEN 40000 AND 60000)
â”‚   â”‚         -- Better as:
â”‚   â”‚         WHERE salary < 40000 OR salary > 60000
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - Place the most **selective conditions first** when using `AND` (though modern optimizers handle this, it helps readability).
â”‚   â”‚
â”‚   â”‚
â”œâ”€â”€ JOINS/
â”‚   â”œâ”€â”€ INNER_JOIN/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Retrieve records with **matching values** in both tables.
â”‚   â”‚       - The most common type of join.
â”‚   â”‚       - Returns rows **only where the join condition is true**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT a.column1, b.column2
â”‚   â”‚       FROM tableA a
â”‚   â”‚       INNER JOIN tableB b
â”‚   â”‚       ON a.common_field = b.common_field;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT employees.name, departments.dept_name
â”‚   â”‚       FROM employees
â”‚   â”‚       INNER JOIN departments
â”‚   â”‚       ON employees.dept_id = departments.dept_id;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       **employees**
â”‚   â”‚       +----+--------+---------+
â”‚   â”‚       | id | name   | dept_id |
â”‚   â”‚       +----+--------+---------+
â”‚   â”‚       | 1  | Alice  |   10    |
â”‚   â”‚       | 2  | Bob    |   20    |
â”‚   â”‚
â”‚   â”‚       **departments**
â”‚   â”‚       +---------+------------+
â”‚   â”‚       | dept_id | dept_name  |
â”‚   â”‚       +---------+------------+
â”‚   â”‚       |   10    | HR         |
â”‚   â”‚       |   30    | Finance    |
â”‚   â”‚
â”‚   â”‚       Result of INNER JOIN:
â”‚   â”‚       +--------+------------+
â”‚   â”‚       | name   | dept_name  |
â”‚   â”‚       +--------+------------+
â”‚   â”‚       | Alice  | HR         |
â”‚   â”‚       +--------+------------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - If no match is found in either table, that row is **excluded**.
â”‚   â”‚       - `INNER JOIN` is equivalent to:
â”‚   â”‚         ```sql
â”‚   â”‚         FROM tableA a, tableB b
â”‚   â”‚         WHERE a.id = b.id
â”‚   â”‚         ```
â”‚   â”‚         But explicit `JOIN` syntax is clearer and preferred.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Always use **ON** for clear join conditions.
â”‚   â”‚       - Qualify column names (`table.column`) to avoid ambiguity.
â”‚   â”‚       - Ensure join fields are indexed for performance.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - Watch for accidental **Cartesian products** when missing join conditions.
â”‚   â”‚       - Use `EXPLAIN` to analyze join execution plans.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ LEFT_JOIN/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Return **all rows** from the **left table**, and matched rows from the right table.
â”‚   â”‚       - If thereâ€™s no match, columns from the right table return **NULL**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT a.column1, b.column2
â”‚   â”‚       FROM tableA a
â”‚   â”‚       LEFT JOIN tableB b
â”‚   â”‚       ON a.common_field = b.common_field;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT employees.name, departments.dept_name
â”‚   â”‚       FROM employees
â”‚   â”‚       LEFT JOIN departments
â”‚   â”‚       ON employees.dept_id = departments.dept_id;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       **employees**
â”‚   â”‚       +----+--------+---------+
â”‚   â”‚       | id | name   | dept_id |
â”‚   â”‚       +----+--------+---------+
â”‚   â”‚       | 1  | Alice  |   10    |
â”‚   â”‚       | 2  | Bob    |   20    |
â”‚   â”‚
â”‚   â”‚       **departments**
â”‚   â”‚       +---------+------------+
â”‚   â”‚       | dept_id | dept_name  |
â”‚   â”‚       +---------+------------+
â”‚   â”‚       |   10    | HR         |
â”‚   â”‚
â”‚   â”‚       Result of LEFT JOIN:
â”‚   â”‚       +--------+------------+
â”‚   â”‚       | name   | dept_name  |
â”‚   â”‚       +--------+------------+
â”‚   â”‚       | Alice  | HR         |
â”‚   â”‚       | Bob    | NULL       |
â”‚   â”‚       +--------+------------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - Always remember: LEFT JOIN = **All Left + Matched Right**.
â”‚   â”‚       - Use `IS NULL` to detect **unmatched rows**:
â”‚   â”‚         ```sql
â”‚   â”‚         WHERE departments.dept_id IS NULL
â”‚   â”‚         ```
â”‚   â”‚         This finds "orphans" â€” rows with no match.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use LEFT JOIN when you need a **complete list** from the primary table, regardless of relationships.
â”‚   â”‚       - Filter carefully â€” applying conditions on the right table can accidentally turn a LEFT JOIN into an INNER JOIN if not handled properly.
â”‚   â”‚
â”‚   â”‚       Example (correct way to filter right table conditionally):
â”‚   â”‚       ```sql
â”‚   â”‚       WHERE departments.dept_name = 'HR' OR departments.dept_name IS NULL
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - Ensure join columns are indexed, especially in large datasets.
â”‚   â”‚       - Avoid unnecessary LEFT JOINs if an INNER JOIN suffices â€” they are heavier.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ RIGHT_JOIN/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Return **all rows** from the **right table**, and matched rows from the left table.
â”‚   â”‚       - If thereâ€™s no match, columns from the left table return **NULL**.
â”‚   â”‚       - Less commonly used than `LEFT JOIN` but functionally identical if you reverse table order.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT a.column1, b.column2
â”‚   â”‚       FROM tableA a
â”‚   â”‚       RIGHT JOIN tableB b
â”‚   â”‚       ON a.common_field = b.common_field;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT employees.name, departments.dept_name
â”‚   â”‚       FROM employees
â”‚   â”‚       RIGHT JOIN departments
â”‚   â”‚       ON employees.dept_id = departments.dept_id;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       **employees**
â”‚   â”‚       +----+--------+---------+
â”‚   â”‚       | id | name   | dept_id |
â”‚   â”‚       +----+--------+---------+
â”‚   â”‚       | 1  | Alice  |   10    |
â”‚   â”‚
â”‚   â”‚       **departments**
â”‚   â”‚       +---------+------------+
â”‚   â”‚       | dept_id | dept_name  |
â”‚   â”‚       +---------+------------+
â”‚   â”‚       |   10    | HR         |
â”‚   â”‚       |   20    | IT         |
â”‚   â”‚
â”‚   â”‚       Result of RIGHT JOIN:
â”‚   â”‚       +--------+------------+
â”‚   â”‚       | name   | dept_name  |
â”‚   â”‚       +--------+------------+
â”‚   â”‚       | Alice  | HR         |
â”‚   â”‚       | NULL   | IT         |
â”‚   â”‚       +--------+------------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - RIGHT JOIN is rarely necessary â€” you can rewrite it as a `LEFT JOIN` by swapping tables.
â”‚   â”‚
â”‚   â”‚       Equivalent:
â”‚   â”‚       ```sql
â”‚   â”‚       A RIGHT JOIN B  â‰¡  B LEFT JOIN A
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Prefer `LEFT JOIN` for readability and consistency unless logic dictates otherwise.
â”‚   â”‚       - Use `IS NULL` checks to identify non-matching left table entries.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - Same optimization rules as LEFT JOIN â€” index your join keys.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ FULL_OUTER_JOIN_and_Workaround/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: 
â”‚   â”‚       - A **FULL OUTER JOIN** returns:
â”‚   â”‚         - All matching rows from both tables (**like INNER JOIN**).
â”‚   â”‚         - Plus **unmatched rows** from both the left and right tables, filling gaps with `NULL`.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Standard SQL Syntax** (âŒ Not supported in MySQL):
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT *
â”‚   â”‚       FROM tableA
â”‚   â”‚       FULL OUTER JOIN tableB
â”‚   â”‚       ON tableA.id = tableB.id;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **MySQL Workaround**:
â”‚   â”‚       - Simulate FULL OUTER JOIN using `UNION` of `LEFT JOIN` and `RIGHT JOIN`.
â”‚   â”‚
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT a.id, a.col1, b.col2
â”‚   â”‚       FROM tableA a
â”‚   â”‚       LEFT JOIN tableB b ON a.id = b.id
â”‚   â”‚
â”‚   â”‚       UNION
â”‚   â”‚
â”‚   â”‚       SELECT a.id, a.col1, b.col2
â”‚   â”‚       FROM tableA a
â”‚   â”‚       RIGHT JOIN tableB b ON a.id = b.id;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       - `UNION` removes duplicates automatically.
â”‚   â”‚       - If you want to **keep duplicates**, use `UNION ALL`.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       ```
â”‚   â”‚       Result = (Matched Rows)
â”‚   â”‚              + (Unmatched Left Rows)
â”‚   â”‚              + (Unmatched Right Rows)
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - If possible, **rethink schema or query logic** to avoid FULL OUTER JOIN in MySQL.
â”‚   â”‚       - Use `COALESCE()` to handle `NULL` values gracefully in results:
â”‚   â”‚         ```sql
â”‚   â”‚         SELECT COALESCE(a.id, b.id) AS id, ...
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - This workaround runs **two joins**, so itâ€™s heavier than standard joins.
â”‚   â”‚       - Ensure proper indexing on join keys to minimize performance hit.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ CROSS_JOIN/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: 
â”‚   â”‚       - A **CROSS JOIN** returns the **Cartesian product** of two tables.
â”‚   â”‚       - Every row from the first table is paired with **every row** from the second table.
â”‚   â”‚       - Typically used when **all combinations** are needed.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT *
â”‚   â”‚       FROM tableA
â”‚   â”‚       CROSS JOIN tableB;
â”‚   â”‚       ```
â”‚   â”‚       - Alternatively (implicit syntax, but risky):
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT *
â”‚   â”‚       FROM tableA, tableB;
â”‚   â”‚       ```
â”‚   â”‚       âš ï¸ Without a `WHERE` clause, this behaves like a CROSS JOIN.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       Table A (2 rows)      Table B (3 rows)
â”‚   â”‚       +----+--------+       +----+-------+
â”‚   â”‚       | id | Name   |       | id | Color |
â”‚   â”‚       +----+--------+       +----+-------+
â”‚   â”‚       | 1  | Alice  |       | 1  | Red   |
â”‚   â”‚       | 2  | Bob    |       | 2  | Blue  |
â”‚   â”‚                           +  | 3  | Green |
â”‚   â”‚
â”‚   â”‚       Result: 2 x 3 = **6 rows**
â”‚   â”‚       +--------+-------+
â”‚   â”‚       | Name   | Color |
â”‚   â”‚       +--------+-------+
â”‚   â”‚       | Alice  | Red   |
â”‚   â”‚       | Alice  | Blue  |
â”‚   â”‚       | Alice  | Green |
â”‚   â”‚       | Bob    | Red   |
â”‚   â”‚       | Bob    | Blue  |
â”‚   â”‚       | Bob    | Green |
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - Be cautious â€” output size = rows_in_A * rows_in_B.
â”‚   â”‚       - Accidental Cartesian products often happen by forgetting join conditions in regular joins.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use CROSS JOIN **only** when you explicitly need combinations (e.g., generating schedules, pairing datasets).
â”‚   â”‚       - For readability, prefer explicit `CROSS JOIN` over comma joins.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - Always estimate row counts before running CROSS JOINs on large tables to avoid crashes or long executions.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ Self_Join/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: 
â”‚   â”‚       - A **Self Join** is when a table is joined **to itself**.
â”‚   â”‚       - Useful for:
â”‚   â”‚         - Hierarchical data (e.g., employees & managers).
â”‚   â”‚         - Comparing rows within the same table.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       - You must use **table aliases** to differentiate instances.
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT e1.name AS Employee, e2.name AS Manager
â”‚   â”‚       FROM employees e1
â”‚   â”‚       LEFT JOIN employees e2
â”‚   â”‚       ON e1.manager_id = e2.emp_id;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       employees table:
â”‚   â”‚       +--------+-----------+------------+
â”‚   â”‚       | emp_id | name      | manager_id |
â”‚   â”‚       +--------+-----------+------------+
â”‚   â”‚       |   1    | Alice     |   NULL     |
â”‚   â”‚       |   2    | Bob       |     1      |
â”‚   â”‚       |   3    | Carol     |     1      |
â”‚   â”‚       |   4    | Dave      |     2      |
â”‚   â”‚
â”‚   â”‚       Result:
â”‚   â”‚       +----------+-----------+
â”‚   â”‚       | Employee | Manager   |
â”‚   â”‚       +----------+-----------+
â”‚   â”‚       | Alice    | NULL      |
â”‚   â”‚       | Bob      | Alice     |
â”‚   â”‚       | Carol    | Alice     |
â”‚   â”‚       | Dave     | Bob       |
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - Always alias tables in self joins to avoid ambiguity.
â”‚   â”‚       - Use `LEFT JOIN` if you want to include top-level entities (like employees without managers).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Clearly name aliases (`parent`, `child`, `e1`, `e2`) to reflect relationships.
â”‚   â”‚       - Ensure proper indexing on the columns used for self-referencing (like `manager_id`).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Use Cases:**
â”‚   â”‚       - Organizational charts.
â”‚   â”‚       - Product categories & subcategories.
â”‚   â”‚       - Detecting duplicates or comparing row values within the same table.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ JOIN_Conditions_ON_vs_USING/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Define how tables are linked in JOIN operations.
â”‚   â”‚
â”‚   â”‚       There are two main ways to specify join conditions:
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **1. Using `ON` Clause**:
â”‚   â”‚       - Most flexible.
â”‚   â”‚       - Allows joining on different column names or complex conditions.
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT e.name, d.dept_name
â”‚   â”‚       FROM employees e
â”‚   â”‚       JOIN departments d
â”‚   â”‚       ON e.dept_id = d.dept_id;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       - Supports compound conditions:
â”‚   â”‚       ```sql
â”‚   â”‚       ON a.id = b.id AND a.status = b.status
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **2. Using `USING` Clause**:
â”‚   â”‚       - Simpler syntax when **both tables share a column with the same name**.
â”‚   â”‚       - Automatically removes duplicate column from output.
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT *
â”‚   â”‚       FROM employees
â”‚   â”‚       JOIN departments
â”‚   â”‚       USING (dept_id);
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       - Equivalent to:
â”‚   â”‚       ```sql
â”‚   â”‚       ON employees.dept_id = departments.dept_id
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Differences:**
â”‚   â”‚       | Feature           | ON Clause          | USING Clause     |
â”‚   â”‚       |-------------------|--------------------|------------------|
â”‚   â”‚       | Column Names      | Can differ         | Must be identical|
â”‚   â”‚       | Output Columns    | Both shown         | One shown        |
â”‚   â”‚       | Complex Conditions| Supported          | Not supported    |
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use `USING` for **simple joins** where column names match exactly.
â”‚   â”‚       - Use `ON` when:
â”‚   â”‚         - Column names differ.
â”‚   â”‚         - You need multiple conditions.
â”‚   â”‚         - You want full control over join logic.
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       -- Prefer ON for clarity in complex joins
â”‚   â”‚       JOIN orders o ON o.customer_id = c.id AND o.status = 'active'
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Note:**
â”‚   â”‚       - Both `ON` and `USING` can be used with `INNER`, `LEFT`, `RIGHT` joins.
â”‚   â”‚       - Avoid mixing styles in large queriesâ€”be consistent!
â”‚   â”‚
â”‚   â”‚
â”œâ”€â”€ Subqueries/
â”‚   â”œâ”€â”€ Scalar_Subquery/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **What is a Scalar Subquery?**
â”‚   â”‚       - A **Scalar Subquery** returns exactly **one value** (one row, one column).
â”‚   â”‚       - Itâ€™s often used where a single value is expected, like in `SELECT`, `WHERE`, or `SET`.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax Example**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, salary
â”‚   â”‚       FROM employees
â”‚   â”‚       WHERE salary > (
â”‚   â”‚           SELECT AVG(salary) FROM employees
â”‚   â”‚       );
â”‚   â”‚       ```
â”‚   â”‚       - This query fetches employees earning **above average salary**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       1ï¸âƒ£ Inner Query:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT AVG(salary) FROM employees;
â”‚   â”‚       -- Returns: 55000
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       2ï¸âƒ£ Outer Query becomes:
â”‚   â”‚       ```sql
â”‚   â”‚       WHERE salary > 55000
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - The subquery **must return exactly one value**.
â”‚   â”‚       - If it returns more than one row â†’ MySQL error:
â”‚   â”‚         ```
â”‚   â”‚         Error: Subquery returns more than 1 row
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚       - Use `LIMIT 1` if necessary to enforce single-row return.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use Scalar Subqueries for dynamic thresholds, calculations, or lookup values.
â”‚   â”‚       - Ensure inner queries are efficient â€” they may execute per row depending on context.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Example in SELECT Clause**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name,
â”‚   â”‚              (SELECT dept_name FROM departments d WHERE d.dept_id = e.dept_id) AS department
â”‚   â”‚       FROM employees e;
â”‚   â”‚       ```
â”‚   â”‚       - Here, the subquery dynamically fetches department names.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ Correlated_Subquery/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **What is a Correlated Subquery?**
â”‚   â”‚       - A **Correlated Subquery** references columns from the **outer query**.
â”‚   â”‚       - It is **executed once per row** of the outer query.
â”‚   â”‚       - Used for row-by-row comparisons.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax Example**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, salary
â”‚   â”‚       FROM employees e
â”‚   â”‚       WHERE salary > (
â”‚   â”‚           SELECT AVG(salary)
â”‚   â”‚           FROM employees
â”‚   â”‚           WHERE dept_id = e.dept_id
â”‚   â”‚       );
â”‚   â”‚       ```
â”‚   â”‚       - This returns employees earning **above the average salary of their own department**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **How It Works**:
â”‚   â”‚       - For **each employee row**, the subquery calculates the departmentâ€™s average salary.
â”‚   â”‚       - Then compares the current employeeâ€™s salary to that value.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Performance Warning:**
â”‚   â”‚       - Correlated subqueries can be **slow** on large datasets because the inner query runs per outer row.
â”‚   â”‚       - Often better replaced by a `JOIN` with precomputed aggregates.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use correlated subqueries for:
â”‚   â”‚         - Existence checks.
â”‚   â”‚         - Complex conditions that are hard to express with joins.
â”‚   â”‚
â”‚   â”‚       - Where possible, refactor like this:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT e.name, e.salary
â”‚   â”‚       FROM employees e
â”‚   â”‚       JOIN (
â”‚   â”‚           SELECT dept_id, AVG(salary) AS avg_sal
â”‚   â”‚           FROM employees
â”‚   â”‚           GROUP BY dept_id
â”‚   â”‚       ) d_avg
â”‚   â”‚       ON e.dept_id = d_avg.dept_id
â”‚   â”‚       WHERE e.salary > d_avg.avg_sal;
â”‚   â”‚       ```
â”‚   â”‚       - This avoids repetitive subquery execution.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Use Cases:**
â”‚   â”‚       - "Find employees who earn more than anyone in department X."
â”‚   â”‚       - "Select products priced above the category average."
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ IN_EXISTS_ANY_ALL_Usage/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Use subqueries to filter data based on dynamic sets or conditions.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **1. `IN` â€” Set Membership Check**
â”‚   â”‚       - Checks if a value exists **within a list** returned by a subquery.
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name
â”‚   â”‚       FROM employees
â”‚   â”‚       WHERE dept_id IN (
â”‚   â”‚           SELECT dept_id FROM departments WHERE location = 'NY'
â”‚   â”‚       );
â”‚   â”‚       ```
â”‚   â”‚       - Subquery returns multiple values.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **2. `EXISTS` â€” Existence Check**
â”‚   â”‚       - Returns TRUE if the subquery returns **any row**.
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name
â”‚   â”‚       FROM employees e
â”‚   â”‚       WHERE EXISTS (
â”‚   â”‚           SELECT 1 FROM departments d WHERE d.dept_id = e.dept_id AND d.location = 'NY'
â”‚   â”‚       );
â”‚   â”‚       ```
â”‚   â”‚       - Efficient for checking if related data **exists**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **3. `ANY` / `SOME` â€” Compare to **Any** Value in Subquery**
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, salary
â”‚   â”‚       FROM employees
â”‚   â”‚       WHERE salary > ANY (
â”‚   â”‚           SELECT salary FROM employees WHERE dept_id = 10
â”‚   â”‚       );
â”‚   â”‚       ```
â”‚   â”‚       - TRUE if condition matches **at least one** value.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **4. `ALL` â€” Compare to **All** Values in Subquery**
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, salary
â”‚   â”‚       FROM employees
â”‚   â”‚       WHERE salary > ALL (
â”‚   â”‚           SELECT salary FROM employees WHERE dept_id = 10
â”‚   â”‚       );
â”‚   â”‚       ```
â”‚   â”‚       - TRUE if condition matches **every** value.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Key Differences:**
â”‚   â”‚       | Operator | Use Case               | Returns TRUE If...         |
â”‚   â”‚       |----------|------------------------|----------------------------|
â”‚   â”‚       | IN       | Value in list          | Value matches any in list  |
â”‚   â”‚       | EXISTS   | Subquery returns rows  | At least one row exists    |
â”‚   â”‚       | ANY      | Compare to any value   | Condition true for â‰¥1      |
â”‚   â”‚       | ALL      | Compare to all values  | Condition true for all     |
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use `EXISTS` for correlated subqueries where you donâ€™t need data, just presence.
â”‚   â”‚       - Use `IN` when the subquery returns a **small set**.
â”‚   â”‚       - Avoid `IN` with large datasets â€” can be slower than joins.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - MySQL often optimizes `EXISTS` better than `IN` for correlated queries.
â”‚   â”‚       - Use `NOT EXISTS` instead of `NOT IN` to handle NULL-safe logic.
â”‚   â”‚
â”‚   â”‚
â”œâ”€â”€ Set_Operations/
â”‚   â”œâ”€â”€ UNION_vs_UNION_ALL/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Combine result sets from two or more `SELECT` queries.
â”‚   â”‚       - Both `UNION` and `UNION ALL` stack datasets **vertically**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT column1, column2 FROM tableA
â”‚   â”‚       UNION         -- or UNION ALL
â”‚   â”‚       SELECT column1, column2 FROM tableB;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Key Differences**:
â”‚   â”‚       | Feature        | UNION              | UNION ALL          |
â”‚   â”‚       |----------------|--------------------|--------------------|
â”‚   â”‚       | Duplicates     | Removed (DISTINCT) | Keeps all          |
â”‚   â”‚       | Performance    | Slower             | Faster             |
â”‚   â”‚       | Use Case       | When uniqueness is | When all data      |
â”‚   â”‚       |                | required           | should be retained |
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT city FROM customers
â”‚   â”‚       UNION
â”‚   â”‚       SELECT city FROM suppliers;
â”‚   â”‚       ```
â”‚   â”‚       - This returns a **distinct list** of cities.
â”‚   â”‚
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT city FROM customers
â”‚   â”‚       UNION ALL
â”‚   â”‚       SELECT city FROM suppliers;
â”‚   â”‚       ```
â”‚   â”‚       - This returns **all cities**, including duplicates.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - Both queries must have:
â”‚   â”‚         - Same number of columns.
â”‚   â”‚         - Compatible data types.
â”‚   â”‚       - `ORDER BY` applies to the **final result**, not individual queries:
â”‚   â”‚       ```sql
â”‚   â”‚       (SELECT ... FROM ...)
â”‚   â”‚       UNION
â”‚   â”‚       (SELECT ... FROM ...)
â”‚   â”‚       ORDER BY column1;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use `UNION ALL` when you **donâ€™t need deduplication** â€” it avoids unnecessary sorting.
â”‚   â”‚       - If deduplication is critical, use `UNION`.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - `UNION` can be expensive due to the internal **sorting and deduplication**.
â”‚   â”‚       - For large datasets, consider:
â”‚   â”‚         ```sql
â”‚   â”‚         SELECT DISTINCT column1 FROM (
â”‚   â”‚             SELECT column1 FROM A
â”‚   â”‚             UNION ALL
â”‚   â”‚             SELECT column1 FROM B
â”‚   â”‚         ) AS combined;
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ INTERSECT_Workaround/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: 
â”‚   â”‚       - `INTERSECT` returns **only rows common** to both `SELECT` queries.
â”‚   â”‚       - Standard SQL supports it, but âŒ **MySQL does not**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Standard SQL Syntax (Not in MySQL)**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT column1 FROM tableA
â”‚   â”‚       INTERSECT
â”‚   â”‚       SELECT column1 FROM tableB;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **MySQL Workaround**:
â”‚   â”‚       Use an `INNER JOIN` or `IN` to simulate `INTERSECT`.
â”‚   â”‚
â”‚   â”‚       **1. INNER JOIN Approach**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT DISTINCT a.column1
â”‚   â”‚       FROM tableA a
â”‚   â”‚       INNER JOIN tableB b ON a.column1 = b.column1;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       **2. IN Clause Approach**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT column1
â”‚   â”‚       FROM tableA
â”‚   â”‚       WHERE column1 IN (
â”‚   â”‚           SELECT column1 FROM tableB
â”‚   â”‚       );
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Example**:
â”‚   â”‚       Find customers who are also suppliers:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT DISTINCT customer_name
â”‚   â”‚       FROM customers
â”‚   â”‚       INNER JOIN suppliers
â”‚   â”‚       ON customers.customer_name = suppliers.supplier_name;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Prefer `INNER JOIN` for better performance over `IN` in large datasets.
â”‚   â”‚       - Always use `DISTINCT` to mimic `INTERSECT` behavior.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - Ensure columns involved are **indexed** for faster joins.
â”‚   â”‚       - Be cautious with subqueries inside `IN` â€” they can degrade performance if unoptimized.
â”‚   â”‚
â”‚   â”‚
â”‚   â””â”€â”€ EXCEPT_Workaround/
â”‚       â””â”€â”€ Explanation:
â”‚           ðŸ”¹ **Purpose**: 
â”‚           - `EXCEPT` returns rows from the **first query** that do **not exist** in the second query.
â”‚           - Standard SQL supports it, but âŒ **MySQL does not**.
â”‚    
â”‚           ---
â”‚           ðŸ“Œ **Standard SQL Syntax (Not in MySQL)**:
â”‚           ```sql
â”‚           SELECT column1 FROM tableA
â”‚           EXCEPT
â”‚           SELECT column1 FROM tableB;
â”‚           ```
â”‚    
â”‚           ---
â”‚           ðŸš¨ **MySQL Workaround**:
â”‚           Use `LEFT JOIN` + `WHERE IS NULL` or `NOT IN` / `NOT EXISTS`.
â”‚    
â”‚           **1. LEFT JOIN Approach**:
â”‚           ```sql
â”‚           SELECT DISTINCT a.column1
â”‚           FROM tableA a
â”‚           LEFT JOIN tableB b ON a.column1 = b.column1
â”‚           WHERE b.column1 IS NULL;
â”‚           ```
â”‚           - This retrieves rows in `tableA` **not present** in `tableB`.
â”‚    
â”‚           **2. NOT IN Approach**:
â”‚           ```sql
â”‚           SELECT column1
â”‚           FROM tableA
â”‚           WHERE column1 NOT IN (
â”‚               SELECT column1 FROM tableB
â”‚           );
â”‚           ```
â”‚    
â”‚           **3. NOT EXISTS Approach**:
â”‚           ```sql
â”‚           SELECT column1
â”‚           FROM tableA a
â”‚           WHERE NOT EXISTS (
â”‚               SELECT 1 FROM tableB b WHERE b.column1 = a.column1
â”‚           );
â”‚           ```
â”‚    
â”‚           ---
â”‚           ðŸ“Š **Example**:
â”‚           Find customers who are **not** suppliers:
â”‚           ```sql
â”‚           SELECT DISTINCT customer_name
â”‚           FROM customers c
â”‚           LEFT JOIN suppliers s
â”‚           ON c.customer_name = s.supplier_name
â”‚           WHERE s.supplier_name IS NULL;
â”‚           ```
â”‚    
â”‚           ---
â”‚           âœ… **Best Practices:**
â”‚           - Use `LEFT JOIN ... IS NULL` for clarity and better handling of NULL-safe logic.
â”‚           - Avoid `NOT IN` if the subquery can return NULLs â€” it may lead to unexpected results.
â”‚    
â”‚           ---
â”‚           âš¡ **Performance Tip:**
â”‚           - `NOT EXISTS` is generally faster and safer than `NOT IN` on large datasets.
â”‚           - Always index the columns used in join or subquery filters.
â”‚    
â”‚    
â”œâ”€â”€ Aggregate_Functions/
â”‚   â”œâ”€â”€ COUNT_SUM_AVG_MIN_MAX/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: 
â”‚   â”‚       - Aggregate functions perform **calculations over sets of rows** and return a single value.
â”‚   â”‚       - Commonly used with `GROUP BY` for summaries.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **1. `COUNT()` â€” Count Rows**
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT COUNT(*) FROM employees;
â”‚   â”‚       SELECT COUNT(salary) FROM employees;
â”‚   â”‚       ```
â”‚   â”‚       - `COUNT(*)` counts **all rows**.
â”‚   â”‚       - `COUNT(column)` counts **non-NULL** values only.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **2. `SUM()` â€” Total of Values**
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT SUM(salary) FROM employees;
â”‚   â”‚       ```
â”‚   â”‚       - Adds up numeric values.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **3. `AVG()` â€” Average Value**
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT AVG(salary) FROM employees;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **4. `MIN()` and `MAX()` â€” Lowest & Highest**
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT MIN(salary), MAX(salary) FROM employees;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Example with GROUP BY**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT department, COUNT(*) AS emp_count, AVG(salary) AS avg_salary
â”‚   â”‚       FROM employees
â”‚   â”‚       GROUP BY department;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - Aggregate functions **ignore NULLs** (except `COUNT(*)`).
â”‚   â”‚       - You **cannot** reference non-aggregated columns without `GROUP BY`.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Alias results (`AS`) for clarity.
â”‚   â”‚       - Use `HAVING` to filter on aggregated values.
â”‚   â”‚       ```sql
â”‚   â”‚       HAVING COUNT(*) > 5
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - Use covering indexes for grouped columns to optimize aggregation.
â”‚   â”‚       - Avoid unnecessary `GROUP BY` on high-cardinality columns.
â”‚   â”‚
â”‚   â”‚
â”‚   â””â”€â”€ GROUP_BY_Behavior/
â”‚       â””â”€â”€ Explanation:
â”‚           ðŸ”¹ **Purpose**: 
â”‚           - The `GROUP BY` clause groups rows that have the same values into **summary rows**.
â”‚           - Typically paired with aggregate functions (`COUNT()`, `SUM()`, etc.).
â”‚    
â”‚           ---
â”‚           ðŸ“Œ **Basic Syntax**:
â”‚           ```sql
â”‚           SELECT column1, AGG_FUNC(column2)
â”‚           FROM table_name
â”‚           GROUP BY column1;
â”‚           ```
â”‚    
â”‚           Example:
â”‚           ```sql
â”‚           SELECT department, COUNT(*) AS emp_count
â”‚           FROM employees
â”‚           GROUP BY department;
â”‚           ```
â”‚    
â”‚           ---
â”‚           ðŸ“Š **Visualization**:
â”‚           Before GROUP BY:
â”‚           +----------+--------+
â”‚           | Dept     | Salary |
â”‚           +----------+--------+
â”‚           | HR       | 50000  |
â”‚           | IT       | 60000  |
â”‚           | HR       | 55000  |
â”‚    
â”‚           After GROUP BY Dept:
â”‚           +----------+-----------+
â”‚           | Dept     | emp_count |
â”‚           +----------+-----------+
â”‚           | HR       |     2     |
â”‚           | IT       |     1     |
â”‚    
â”‚           ---
â”‚           ðŸš¨ **Important Rules:**
â”‚           - Every column in `SELECT` must be:
â”‚             - In the `GROUP BY`, or
â”‚             - Wrapped in an aggregate function.
â”‚    
â”‚           - MySQL (with default settings) allows non-standard behavior (e.g., selecting columns not in `GROUP BY`), but this is unsafe and non-portable.
â”‚    
â”‚           ---
â”‚           âœ… **Best Practices:**
â”‚           - Stick to strict SQL standards: only group or aggregate.
â”‚           - Use `HAVING` to filter **after grouping**:
â”‚             ```sql
â”‚             HAVING COUNT(*) > 3
â”‚             ```
â”‚    
â”‚           ---
â”‚           âš¡ **Performance Tips:**
â”‚           - Index columns used in `GROUP BY` for faster grouping.
â”‚           - Avoid grouping on columns with many unique values unless necessary (high-cardinality columns).
â”‚    
â”‚           ---
â”‚           ðŸ”¹ **Advanced Example**:
â”‚           ```sql
â”‚           SELECT dept_id, AVG(salary)
â”‚           FROM employees
â”‚           GROUP BY dept_id
â”‚           HAVING AVG(salary) > 50000;
â”‚           ```
â”œâ”€â”€ Modifying_Data/
â”‚   â”œâ”€â”€ INSERT_Single_and_Bulk/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: 
â”‚   â”‚       - The `INSERT` statement adds **new rows** to a table.
â”‚   â”‚       - Supports both **single row** and **bulk inserts**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **1. Single Row Insert**:
â”‚   â”‚       ```sql
â”‚   â”‚       INSERT INTO employees (emp_id, name, department, salary)
â”‚   â”‚       VALUES (1, 'Alice', 'HR', 60000);
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       - Specify columns explicitly for clarity and safety.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **2. Bulk Insert**:
â”‚   â”‚       ```sql
â”‚   â”‚       INSERT INTO employees (emp_id, name, department, salary)
â”‚   â”‚       VALUES 
â”‚   â”‚           (2, 'Bob', 'IT', 55000),
â”‚   â”‚           (3, 'Carol', 'Finance', 70000);
â”‚   â”‚       ```
â”‚   â”‚       - More efficient than multiple single inserts.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **3. Insert from SELECT**:
â”‚   â”‚       ```sql
â”‚   â”‚       INSERT INTO archived_employees (emp_id, name, department)
â”‚   â”‚       SELECT emp_id, name, department
â”‚   â”‚       FROM employees
â”‚   â”‚       WHERE status = 'inactive';
â”‚   â”‚       ```
â”‚   â”‚       - Copies data between tables.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - If you omit column names, values must match **all columns in order** â€” avoid this practice.
â”‚   â”‚       - Respect constraints: `NOT NULL`, `UNIQUE`, `FOREIGN KEY`.
â”‚   â”‚       - Use `DEFAULT` keyword to insert default values.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Always list column names in `INSERT`.
â”‚   â”‚       - Use bulk inserts when adding multiple rows to reduce transaction overhead.
â”‚   â”‚       - Validate data types before insertion to avoid runtime errors.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tips:**
â”‚   â”‚       - For massive inserts:
â”‚   â”‚         - Disable indexes temporarily (if possible) and rebuild after.
â”‚   â”‚         - Use transactions to batch commits:
â”‚   â”‚         ```sql
â”‚   â”‚         START TRANSACTION;
â”‚   â”‚         -- multiple INSERTs
â”‚   â”‚         COMMIT;
â”‚   â”‚         ```
â”‚   â”‚       - Use `LOAD DATA INFILE` for high-performance bulk loading.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ UPDATE_with_JOIN/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: 
â”‚   â”‚       - The `UPDATE` statement modifies existing rows in a table.
â”‚   â”‚       - You can update based on conditions â€” and with JOINs, you can update using data from other tables.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Basic UPDATE Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       UPDATE employees
â”‚   â”‚       SET salary = salary * 1.1
â”‚   â”‚       WHERE department = 'HR';
â”‚   â”‚       ```
â”‚   â”‚       - Increases salary by 10% for HR employees.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **UPDATE with JOIN Syntax** (MySQL Style):
â”‚   â”‚       ```sql
â”‚   â”‚       UPDATE employees e
â”‚   â”‚       JOIN departments d ON e.dept_id = d.dept_id
â”‚   â”‚       SET e.bonus = 1000
â”‚   â”‚       WHERE d.dept_name = 'Finance';
â”‚   â”‚       ```
â”‚   â”‚       - This assigns bonuses to employees in Finance by referencing the `departments` table.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       - Join is performed first to identify target rows.
â”‚   â”‚       - Then, the `SET` clause applies updates.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - Without a `WHERE` clause, **all rows** will be updated!
â”‚   â”‚       ```sql
â”‚   â”‚       UPDATE table SET column = value;  -- Dangerous if unfiltered
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       - MySQL requires explicit JOIN syntax; you can't use subqueries in the `SET` clause like some other RDBMS.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Always **backup** before mass updates.
â”‚   â”‚       - Use `WHERE` carefully to limit scope.
â”‚   â”‚       - Test your `JOIN` first using a `SELECT` before applying `UPDATE`.
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT e.*
â”‚   â”‚       FROM employees e
â”‚   â”‚       JOIN departments d ON e.dept_id = d.dept_id
â”‚   â”‚       WHERE d.dept_name = 'Finance';
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - For large updates, batch them if possible.
â”‚   â”‚       - Ensure join keys are indexed.
â”‚   â”‚       - Use transactions to control rollback if needed:
â”‚   â”‚       ```sql
â”‚   â”‚       START TRANSACTION;
â”‚   â”‚       UPDATE ...;
â”‚   â”‚       COMMIT;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚
â”‚   â””â”€â”€ DELETE_with_Conditions/
â”‚       â””â”€â”€ Explanation:
â”‚           ðŸ”¹ **Purpose**: 
â”‚           - The `DELETE` statement removes rows from a table based on specified conditions.
â”‚           - Without conditions, it will delete **all rows** â€” so caution is critical!
â”‚    
â”‚           ---
â”‚           ðŸ“Œ **Basic DELETE Syntax**:
â”‚           ```sql
â”‚           DELETE FROM employees
â”‚           WHERE department = 'HR';
â”‚           ```
â”‚           - Deletes all employees in the HR department.
â”‚    
â”‚           ---
â”‚           ðŸ“Œ **DELETE with JOIN** (MySQL Specific):
â”‚           ```sql
â”‚           DELETE e
â”‚           FROM employees e
â”‚           JOIN departments d ON e.dept_id = d.dept_id
â”‚           WHERE d.dept_name = 'Finance';
â”‚           ```
â”‚           - Deletes employees belonging to the Finance department.
â”‚    
â”‚           ---
â”‚           ðŸš¨ **Critical Notes:**
â”‚           - **Never run**:
â”‚             ```sql
â”‚             DELETE FROM table_name;
â”‚             ```
â”‚             Unless you intend to wipe all data.
â”‚    
â”‚           - Use `LIMIT` for controlled deletions:
â”‚             ```sql
â”‚             DELETE FROM logs
â”‚             ORDER BY created_at ASC
â”‚             LIMIT 1000;
â”‚             ```
â”‚    
â”‚           ---
â”‚           âœ… **Best Practices:**
â”‚           - Always run a `SELECT` version of your `DELETE` query first to preview affected rows.
â”‚           - For large deletes, consider **batch deletes** to avoid locking issues.
â”‚           - Use foreign key constraints with `ON DELETE CASCADE` carefully to handle related data.
â”‚    
â”‚           ---
â”‚           âš¡ **Performance Tip:**
â”‚           - Large deletions can cause table bloat; consider `TRUNCATE` for full-table wipes (faster, but irreversible).
â”‚           - Example:
â”‚             ```sql
â”‚             TRUNCATE TABLE temp_data;
â”‚             ```
â”‚           - Note: `TRUNCATE` doesnâ€™t activate triggers and resets AUTO_INCREMENT.
â”‚    
â”‚    
â”œâ”€â”€ Advanced_Clauses/
â”‚   â”œâ”€â”€ CASE_WHEN/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: 
â”‚   â”‚       - `CASE WHEN` allows **if-else logic** within SQL queries.
â”‚   â”‚       - It returns values based on conditions evaluated per row.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name,
â”‚   â”‚              CASE 
â”‚   â”‚                  WHEN salary > 70000 THEN 'High'
â”‚   â”‚                  WHEN salary BETWEEN 50000 AND 70000 THEN 'Medium'
â”‚   â”‚                  ELSE 'Low'
â”‚   â”‚              END AS salary_band
â”‚   â”‚       FROM employees;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Example Output**:
â”‚   â”‚       +--------+-------------+
â”‚   â”‚       | name   | salary_band |
â”‚   â”‚       +--------+-------------+
â”‚   â”‚       | Alice  | Medium      |
â”‚   â”‚       | Bob    | High        |
â”‚   â”‚       +--------+-------------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Forms of CASE**:
â”‚   â”‚       1ï¸âƒ£ **Searched CASE** (most common):
â”‚   â”‚       ```sql
â”‚   â”‚       CASE WHEN condition THEN result ...
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       2ï¸âƒ£ **Simple CASE** (compares a single expression):
â”‚   â”‚       ```sql
â”‚   â”‚       CASE dept_id
â”‚   â”‚           WHEN 1 THEN 'HR'
â”‚   â”‚           WHEN 2 THEN 'IT'
â”‚   â”‚           ELSE 'Other'
â”‚   â”‚       END
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - The `ELSE` clause is optional but recommended for completeness.
â”‚   â”‚       - The first matching `WHEN` is executed â€” remaining conditions are skipped.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use `CASE` for dynamic categorization, conditional calculations, or pivot-like queries.
â”‚   â”‚       - Keep conditions clear and avoid overly complex nesting.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Use Cases:**
â”‚   â”‚       - Custom sorting:
â”‚   â”‚         ```sql
â”‚   â”‚         ORDER BY 
â”‚   â”‚           CASE WHEN status = 'urgent' THEN 1
â”‚   â”‚                WHEN status = 'normal' THEN 2
â”‚   â”‚                ELSE 3
â”‚   â”‚           END
â”‚   â”‚         ```
â”‚   â”‚       - Conditional aggregation:
â”‚   â”‚         ```sql
â”‚   â”‚         SUM(CASE WHEN gender = 'M' THEN 1 ELSE 0 END) AS male_count
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ IFNULL_and_COALESCE/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: 
â”‚   â”‚       - Replace `NULL` values with specified defaults during query execution.
â”‚   â”‚       - Ensures cleaner outputs and avoids unexpected `NULL` propagation in results.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **1. `IFNULL()` â€” MySQL-Specific**
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, IFNULL(bonus, 0) AS bonus_amount
â”‚   â”‚       FROM employees;
â”‚   â”‚       ```
â”‚   â”‚       - If `bonus` is `NULL`, returns `0`.
â”‚   â”‚       - Syntax: `IFNULL(expression, replacement)`
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **2. `COALESCE()` â€” ANSI Standard**
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, COALESCE(bonus, commission, 0) AS total_bonus
â”‚   â”‚       FROM employees;
â”‚   â”‚       ```
â”‚   â”‚       - Returns the **first non-NULL** value from the list.
â”‚   â”‚       - More flexible than `IFNULL()` because it accepts multiple arguments.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Key Differences**:
â”‚   â”‚       | Feature      | IFNULL()     | COALESCE()  |
â”‚   â”‚       |--------------|--------------|-------------|
â”‚   â”‚       | Portability  | MySQL only   | ANSI SQL    |
â”‚   â”‚       | Args         | 2 arguments  | 2+ arguments|
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Example Scenario**:
â”‚   â”‚       Handling optional contact info:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, COALESCE(phone, email, 'No Contact') AS contact_info
â”‚   â”‚       FROM customers;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use `COALESCE()` for cross-database compatibility.
â”‚   â”‚       - Always define a meaningful default value when substituting `NULL`.
â”‚   â”‚       - Be cautious with data types â€” ensure replacements match expected output types.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - Both functions are lightweight but avoid wrapping unnecessary columns.
â”‚   â”‚       - Use in reporting queries to prevent `NULL` from cluttering outputs.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ WINDOW_Functions_OVER_PARTITION_BY/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: 
â”‚   â”‚       - **Window functions** perform calculations **across sets of rows** related to the current row.
â”‚   â”‚       - Unlike `GROUP BY`, they **retain individual rows** while providing aggregates or rankings.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Core Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, department, salary,
â”‚   â”‚              AVG(salary) OVER (PARTITION BY department) AS dept_avg_salary
â”‚   â”‚       FROM employees;
â”‚   â”‚       ```
â”‚   â”‚       - `OVER()` defines the "window" of rows to operate on.
â”‚   â”‚       - `PARTITION BY` divides data into groups (like GROUP BY, but non-destructive).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Example Output**:
â”‚   â”‚       +--------+------------+--------+-----------------+
â”‚   â”‚       | name   | department | salary | dept_avg_salary |
â”‚   â”‚       +--------+------------+--------+-----------------+
â”‚   â”‚       | Alice  | HR         | 60000  |     55000       |
â”‚   â”‚       | Bob    | HR         | 50000  |     55000       |
â”‚   â”‚       | Carol  | IT         | 70000  |     70000       |
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Common Window Functions**:
â”‚   â”‚       - `ROW_NUMBER() OVER (...)`   â†’ Unique row numbering.
â”‚   â”‚       - `RANK() OVER (...)`         â†’ Ranking with gaps.
â”‚   â”‚       - `DENSE_RANK() OVER (...)`   â†’ Ranking without gaps.
â”‚   â”‚       - `SUM()`, `AVG()`, `COUNT()` as windowed aggregates.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **ORDER BY in Windows**:
â”‚   â”‚       - You can define order within partitions:
â”‚   â”‚       ```sql
â”‚   â”‚       ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC)
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - Requires MySQL **8.0+**.
â”‚   â”‚       - Window functions **cannot** be used in `WHERE` â€” use them in `SELECT` or `ORDER BY`.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use for running totals, rankings, percentiles without losing row-level detail.
â”‚   â”‚       - Prefer `ROW_NUMBER()` for pagination solutions over OFFSET in some cases.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - Proper indexing helps, but window functions often require sorting â€” be mindful on large datasets.
â”‚   â”‚       - Use partitions smartly to limit computation scope.
â”‚   â”‚
â”‚   â”‚
â”‚   â””â”€â”€ CTE_WITH_Clause/
â”‚       â””â”€â”€ Explanation:
â”‚           ðŸ”¹ **Purpose**: 
â”‚           - A **Common Table Expression (CTE)** allows you to define a temporary result set using `WITH`.
â”‚           - Makes complex queries easier to read and maintain.
â”‚           - Think of it as a named subquery that you can reference within your main query.
â”‚    
â”‚           ---
â”‚           ðŸ“Œ **Basic Syntax**:
â”‚           ```sql
â”‚           WITH dept_avg AS (
â”‚               SELECT department, AVG(salary) AS avg_salary
â”‚               FROM employees
â”‚               GROUP BY department
â”‚           )
â”‚           SELECT e.name, e.salary, d.avg_salary
â”‚           FROM employees e
â”‚           JOIN dept_avg d ON e.department = d.department;
â”‚           ```
â”‚    
â”‚           ---
â”‚           ðŸ”¹ **Key Features**:
â”‚           - Improves readability over nested subqueries.
â”‚           - Can be **recursive** for hierarchical data (e.g., org charts, tree structures).
â”‚    
â”‚           ---
â”‚           ðŸ“Œ **Recursive CTE Example**:
â”‚           ```sql
â”‚           WITH RECURSIVE hierarchy AS (
â”‚               SELECT emp_id, name, manager_id
â”‚               FROM employees
â”‚               WHERE manager_id IS NULL
â”‚    
â”‚               UNION ALL
â”‚    
â”‚               SELECT e.emp_id, e.name, e.manager_id
â”‚               FROM employees e
â”‚               JOIN hierarchy h ON e.manager_id = h.emp_id
â”‚           )
â”‚           SELECT * FROM hierarchy;
â”‚           ```
â”‚    
â”‚           ---
â”‚           ðŸš¨ **Important Notes:**
â”‚           - CTEs exist **only during execution** â€” they are not stored.
â”‚           - Each CTE name must be unique within the query.
â”‚           - MySQL supports CTEs from version **8.0+**.
â”‚    
â”‚           ---
â”‚           âœ… **Best Practices:**
â”‚           - Use CTEs to break down multi-step queries logically.
â”‚           - Prefer CTEs over deeply nested subqueries for better maintainability.
â”‚           - For repeated subqueries, CTEs can enhance performance by avoiding duplication.
â”‚    
â”‚           ---
â”‚           âš¡ **Performance Tip:**
â”‚           - CTEs are **inline views**; they donâ€™t automatically optimize like materialized views.
â”‚           - For large datasets, check if subqueries or temporary tables perform better.
â”‚    
â”‚    
Given_a_Question/
â”œâ”€â”€ How_to_Interpret_Requirements/
â”‚   â””â”€â”€ Explanation:
â”‚       ðŸ”¹ **Step 1: Understand Whatâ€™s Being Asked**
â”‚       - Is it asking for:
â”‚         - A **list**? (likely a `SELECT`)
â”‚         - A **calculation**? (aggregates, window functions)
â”‚         - A **filter**? (WHERE, HAVING)
â”‚         - A **transformation**? (CASE, JOINs)
â”‚
â”‚       - **Clarify ambiguous terms**:
â”‚         - "Top customers" â†’ By what metric? Revenue? Number of orders?
â”‚         - "Active users" â†’ Define "active" (last 30 days? status flag?)
â”‚
â”‚       ---
â”‚       ðŸ”¹ **Step 2: Identify Key Elements**
â”‚       - **Tables involved**.
â”‚       - **Relationships** (Do you need JOINs?).
â”‚       - **Filters** (`WHERE`, `HAVING`?).
â”‚       - **Ordering or Limits** (`ORDER BY`, `LIMIT`?).
â”‚       - **Aggregations** (`GROUP BY`?).
â”‚
â”‚       ---
â”‚       ðŸ”¹ **Example Problem Breakdown**:
â”‚       **Q:** "Find departments with more than 5 employees earning above 60K."
â”‚
â”‚       1ï¸âƒ£ Tables: `employees`
â”‚       2ï¸âƒ£ Filter: `salary > 60000`
â”‚       3ï¸âƒ£ Grouping: By `department`
â”‚       4ï¸âƒ£ Condition on group: `HAVING COUNT(*) > 5`
â”‚
â”‚       Final Query:
â”‚       ```sql
â”‚       SELECT department, COUNT(*) AS emp_count
â”‚       FROM employees
â”‚       WHERE salary > 60000
â”‚       GROUP BY department
â”‚       HAVING emp_count > 5;
â”‚       ```
â”‚
â”‚       ---
â”‚       âœ… **Best Practices:**
â”‚       - **Sketch** intermediate steps on paper before writing SQL.
â”‚       - Think in terms of **data flow** â€” how is data reduced or transformed at each stage?
â”‚       - Always ask: "Can this be solved differently for better performance or clarity?"
â”‚   
â”‚   
â”œâ”€â”€ Identify_Multiple_Approaches/
â”‚   â””â”€â”€ Explanation:
â”‚       ðŸ”¹ **Purpose**: 
â”‚       - For any SQL problem, thereâ€™s often **more than one way** to solve it.
â”‚       - The best solution depends on:
â”‚         - **Performance**
â”‚         - **Readability**
â”‚         - **Maintainability**
â”‚         - Dataset size & indexes
â”‚
â”‚       ---
â”‚       ðŸ“Œ **1. JOINs vs Subqueries**
â”‚       **Problem:** Get names of employees working in 'HR'.
â”‚
â”‚       ðŸ”¸ **Using JOIN**:
â”‚       ```sql
â”‚       SELECT e.name
â”‚       FROM employees e
â”‚       JOIN departments d ON e.dept_id = d.dept_id
â”‚       WHERE d.dept_name = 'HR';
â”‚       ```
â”‚
â”‚       ðŸ”¸ **Using Subquery**:
â”‚       ```sql
â”‚       SELECT name
â”‚       FROM employees
â”‚       WHERE dept_id = (
â”‚           SELECT dept_id FROM departments WHERE dept_name = 'HR'
â”‚       );
â”‚       ```
â”‚
â”‚       âœ… **When to Use**:
â”‚       - **JOINs**: Better for multi-row matches, more readable for complex relationships.
â”‚       - **Subqueries**: Simpler for single-value lookups (scalar) or filtering with `IN`.
â”‚
â”‚       ---
â”‚       ðŸ“Œ **2. CASE vs IF**
â”‚       - MySQL supports both, but:
â”‚         - `CASE` = ANSI standard, more powerful, supports complex conditions.
â”‚         - `IF` = MySQL-specific, simpler binary choice.
â”‚
â”‚       Example:
â”‚       ```sql
â”‚       SELECT name,
â”‚              CASE WHEN salary > 60000 THEN 'High' ELSE 'Normal' END AS category
â”‚       FROM employees;
â”‚       ```
â”‚       vs
â”‚       ```sql
â”‚       SELECT name, IF(salary > 60000, 'High', 'Normal') AS category
â”‚       FROM employees;
â”‚       ```
â”‚
â”‚       âœ… **Best Practice**: Prefer `CASE` for portability and complex logic.
â”‚
â”‚       ---
â”‚       ðŸ“Œ **3. CTE vs Nested Queries**
â”‚       **Problem:** Get departments where avg salary > 50K.
â”‚
â”‚       ðŸ”¸ **Using Nested Query**:
â”‚       ```sql
â”‚       SELECT department, avg_salary
â”‚       FROM (
â”‚           SELECT department, AVG(salary) AS avg_salary
â”‚           FROM employees
â”‚           GROUP BY department
â”‚       ) AS dept_avg
â”‚       WHERE avg_salary > 50000;
â”‚       ```
â”‚
â”‚       ðŸ”¸ **Using CTE**:
â”‚       ```sql
â”‚       WITH dept_avg AS (
â”‚           SELECT department, AVG(salary) AS avg_salary
â”‚           FROM employees
â”‚           GROUP BY department
â”‚       )
â”‚       SELECT department, avg_salary
â”‚       FROM dept_avg
â”‚       WHERE avg_salary > 50000;
â”‚       ```
â”‚
â”‚       âœ… **When to Use**:
â”‚       - **CTEs** improve readability, especially with multi-step logic.
â”‚       - Nested queries can be faster in simple cases but harder to maintain.
â”‚
â”‚       ---
â”‚       âš¡ **Golden Rule**:
â”‚       - Always think: "Whatâ€™s clearer for future developers AND what scales better?"
â”‚       - Test alternatives on large datasets to compare execution plans.
â”‚   
â”‚   
â”œâ”€â”€ Common_Question_Types/
â”‚   â”œâ”€â”€ Top_N_Queries/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: 
â”‚   â”‚       - Retrieve the **top N records** based on a specific ordering (e.g., highest salaries, latest dates).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Basic Syntax (MySQL)**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, salary
â”‚   â”‚       FROM employees
â”‚   â”‚       ORDER BY salary DESC
â”‚   â”‚       LIMIT 5;
â”‚   â”‚       ```
â”‚   â”‚       - This returns the **top 5 highest-paid employees**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Top-N Per Group (Advanced Pattern)**:
â”‚   â”‚       - Find top 2 salaries **per department**.
â”‚   â”‚
â”‚   â”‚       Using **Window Functions** (MySQL 8.0+):
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, department, salary
â”‚   â”‚       FROM (
â”‚   â”‚           SELECT name, department, salary,
â”‚   â”‚                  ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS rank
â”‚   â”‚           FROM employees
â”‚   â”‚       ) ranked
â”‚   â”‚       WHERE rank <= 2;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - Always pair `LIMIT` with `ORDER BY` for deterministic results.
â”‚   â”‚       - Without `ORDER BY`, `LIMIT` returns arbitrary rows.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use indexes aligned with `ORDER BY` columns to speed up Top-N queries.
â”‚   â”‚       - For pagination, combine `ORDER BY` + `LIMIT` + `OFFSET`.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Alternative Approach (If No Window Functions)**:
â”‚   â”‚       - In older MySQL versions, simulate Top-N per group using correlated subqueries:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT e1.*
â”‚   â”‚       FROM employees e1
â”‚   â”‚       WHERE 2 > (
â”‚   â”‚           SELECT COUNT(*)
â”‚   â”‚           FROM employees e2
â”‚   â”‚           WHERE e2.department = e1.department
â”‚   â”‚             AND e2.salary > e1.salary
â”‚   â”‚       );
â”‚   â”‚       ```
â”‚   â”‚       - This is less efficient but works where window functions arenâ€™t available.
â”‚   â”‚
â”‚   â”‚
Given_a_Question/
â”œâ”€â”€ Common_Question_Types/
â”‚   â”œâ”€â”€ Finding_Duplicates/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: 
â”‚   â”‚       - Identify rows where certain columns have **duplicate values**.
â”‚   â”‚       - Useful for detecting data integrity issues or enforcing uniqueness manually.
â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Basic Pattern**:
â”‚   â”‚       - Use `GROUP BY` + `HAVING COUNT(*) > 1`.
â”‚   â”‚
â”‚   â”‚       Example: Find duplicate email addresses in a `users` table.
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT email, COUNT(*) AS occurrences
â”‚   â”‚       FROM users
â”‚   â”‚       GROUP BY email
â”‚   â”‚       HAVING COUNT(*) > 1;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       users table:
â”‚   â”‚       +----+-------------+
â”‚   â”‚       | id | email       |
â”‚   â”‚       +----+-------------+
â”‚   â”‚       | 1  | a@test.com  |
â”‚   â”‚       | 2  | b@test.com  |
â”‚   â”‚       | 3  | a@test.com  |
â”‚   â”‚
â”‚   â”‚       Result:
â”‚   â”‚       +-------------+-------------+
â”‚   â”‚       | email       | occurrences |
â”‚   â”‚       +-------------+-------------+
â”‚   â”‚       | a@test.com  |      2      |
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **To Retrieve Full Duplicate Rows**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT u.*
â”‚   â”‚       FROM users u
â”‚   â”‚       JOIN (
â”‚   â”‚           SELECT email
â”‚   â”‚           FROM users
â”‚   â”‚           GROUP BY email
â”‚   â”‚           HAVING COUNT(*) > 1
â”‚   â”‚       ) dup ON u.email = dup.email;
â”‚   â”‚       ```
â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - Duplicates depend on **which columns** you're checking â€” define the criteria clearly.
â”‚   â”‚       - NULLs are treated as valid groupable values in MySQL.
â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Regularly audit tables where uniqueness is critical.
â”‚   â”‚       - Enforce `UNIQUE` constraints where possible to prevent duplicates.
â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Cleanup Tip**:
â”‚   â”‚       - After identifying duplicates, you can delete them while keeping one:
â”‚   â”‚       ```sql
â”‚   â”‚       DELETE u1 FROM users u1
â”‚   â”‚       INNER JOIN users u2 
â”‚   â”‚       ON u1.email = u2.email AND u1.id > u2.id;
â”‚   â”‚       ```
â”‚   â”‚       - This keeps the lowest `id` record.
â”‚   â”œâ”€â”€ Finding_Duplicates/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: 
â”‚   â”‚       - Identify rows where certain columns have **duplicate values**.
â”‚   â”‚       - Useful for detecting data integrity issues or enforcing uniqueness manually.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Basic Pattern**:
â”‚   â”‚       - Use `GROUP BY` + `HAVING COUNT(*) > 1`.
â”‚   â”‚
â”‚   â”‚       Example: Find duplicate email addresses in a `users` table.
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT email, COUNT(*) AS occurrences
â”‚   â”‚       FROM users
â”‚   â”‚       GROUP BY email
â”‚   â”‚       HAVING COUNT(*) > 1;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       users table:
â”‚   â”‚       +----+-------------+
â”‚   â”‚       | id | email       |
â”‚   â”‚       +----+-------------+
â”‚   â”‚       | 1  | a@test.com  |
â”‚   â”‚       | 2  | b@test.com  |
â”‚   â”‚       | 3  | a@test.com  |
â”‚   â”‚
â”‚   â”‚       Result:
â”‚   â”‚       +-------------+-------------+
â”‚   â”‚       | email       | occurrences |
â”‚   â”‚       +-------------+-------------+
â”‚   â”‚       | a@test.com  |      2      |
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **To Retrieve Full Duplicate Rows**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT u.*
â”‚   â”‚       FROM users u
â”‚   â”‚       JOIN (
â”‚   â”‚           SELECT email
â”‚   â”‚           FROM users
â”‚   â”‚           GROUP BY email
â”‚   â”‚           HAVING COUNT(*) > 1
â”‚   â”‚       ) dup ON u.email = dup.email;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - Duplicates depend on **which columns** you're checking â€” define the criteria clearly.
â”‚   â”‚       - NULLs are treated as valid groupable values in MySQL.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Regularly audit tables where uniqueness is critical.
â”‚   â”‚       - Enforce `UNIQUE` constraints where possible to prevent duplicates.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Cleanup Tip**:
â”‚   â”‚       - After identifying duplicates, you can delete them while keeping one:
â”‚   â”‚       ```sql
â”‚   â”‚       DELETE u1 FROM users u1
â”‚   â”‚       INNER JOIN users u2 
â”‚   â”‚       ON u1.email = u2.email AND u1.id > u2.id;
â”‚   â”‚       ```
â”‚   â”‚       - This keeps the lowest `id` record.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ Percentage_Calculations/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: 
â”‚   â”‚       - Calculate percentages such as:
â”‚   â”‚         - **Contribution to total**.
â”‚   â”‚         - **Category distributions**.
â”‚   â”‚         - Percent rankings.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **1. Contribution to Total**:
â”‚   â”‚       Example: What percentage of total sales does each customer contribute?
â”‚   â”‚
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT customer_id, 
â”‚   â”‚              SUM(amount) AS customer_total,
â”‚   â”‚              ROUND(SUM(amount) / total_sales.total * 100, 2) AS percentage
â”‚   â”‚       FROM orders, 
â”‚   â”‚            (SELECT SUM(amount) AS total FROM orders) AS total_sales
â”‚   â”‚       GROUP BY customer_id;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **2. Using Window Functions (MySQL 8.0+):**
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT customer_id, amount,
â”‚   â”‚              ROUND(amount / SUM(amount) OVER () * 100, 2) AS pct_of_total
â”‚   â”‚       FROM orders;
â”‚   â”‚       ```
â”‚   â”‚       - This calculates each row's percentage of the **overall total**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **3. Percent Rank Example**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, salary,
â”‚   â”‚              PERCENT_RANK() OVER (ORDER BY salary DESC) AS salary_rank_pct
â”‚   â”‚       FROM employees;
â”‚   â”‚       ```
â”‚   â”‚       - Shows where each employee stands in salary distribution.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - Always multiply by `100` to convert fractions to percentages.
â”‚   â”‚       - Use `ROUND()` to control decimal precision in outputs.
â”‚   â”‚       - Be cautious of **division by zero** when calculating percentages.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - For readability, alias percentage columns clearly (`pct_of_total`, `percent_share`).
â”‚   â”‚       - Use window functions for cleaner syntax when supported.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - Pre-calculate grand totals if reused across many queries.
â”‚   â”‚       - Avoid repeating subqueries for totalsâ€”use CTEs or JOIN once where possible.
â”‚   â”‚
â”‚   â”‚
â”‚   â””â”€â”€ Date_Based_Queries/
â”‚       â””â”€â”€ Explanation:
â”‚           ðŸ”¹ **Purpose**: 
â”‚           - Work with dates for filtering, calculating intervals, grouping by periods, etc.
â”‚           - Essential for time-based reporting (e.g., "last 7 days", "monthly sales").
â”‚    
â”‚           ---
â”‚           ðŸ“Œ **1. Filtering by Date Range**:
â”‚           ```sql
â”‚           SELECT * 
â”‚           FROM orders
â”‚           WHERE order_date BETWEEN '2024-04-01' AND '2024-04-30';
â”‚           ```
â”‚           - Use `BETWEEN` for inclusive date ranges.
â”‚    
â”‚           ---
â”‚           ðŸ“Œ **2. Dynamic Date Filters**:
â”‚           - Last 7 days:
â”‚           ```sql
â”‚           WHERE order_date >= CURDATE() - INTERVAL 7 DAY
â”‚           ```
â”‚    
â”‚           - Current Month:
â”‚           ```sql
â”‚           WHERE MONTH(order_date) = MONTH(CURDATE())
â”‚             AND YEAR(order_date) = YEAR(CURDATE())
â”‚           ```
â”‚    
â”‚           ---
â”‚           ðŸ“Œ **3. Calculating Date Differences**:
â”‚           ```sql
â”‚           SELECT DATEDIFF(delivery_date, order_date) AS days_to_deliver
â”‚           FROM orders;
â”‚           ```
â”‚           - Returns difference in days.
â”‚    
â”‚           ---
â”‚           ðŸ“Œ **4. Grouping by Month or Year**:
â”‚           ```sql
â”‚           SELECT YEAR(order_date) AS year, MONTH(order_date) AS month, COUNT(*) AS orders_count
â”‚           FROM orders
â”‚           GROUP BY YEAR(order_date), MONTH(order_date)
â”‚           ORDER BY year, month;
â”‚           ```
â”‚    
â”‚           ---
â”‚           ðŸš¨ **Important Notes:**
â”‚           - Avoid wrapping columns in functions in `WHERE` clauses if possible (it prevents index usage):
â”‚             ```sql
â”‚             WHERE DATE(order_date) = '2024-04-27'   -- âŒ
â”‚             ```
â”‚             Better:
â”‚             ```sql
â”‚             WHERE order_date >= '2024-04-27' AND order_date < '2024-04-28'  -- âœ…
â”‚             ```
â”‚    
â”‚           - Be mindful of **time portions** in `DATETIME` fields.
â”‚    
â”‚           ---
â”‚           âœ… **Best Practices:**
â”‚           - Store dates in `DATE` or `DATETIME` formats â€” never as strings.
â”‚           - Use `CURDATE()`, `NOW()`, `LAST_DAY()`, etc., for dynamic queries.
â”‚    
â”‚           ---
â”‚           âš¡ **Performance Tip:**
â”‚           - Index date columns when frequently filtering by ranges.
â”‚           - For partitioned tables, consider partitioning by date for large historical datasets. 