Foundations_And_Core_Concepts/
â”œâ”€â”€ SQL_Basics/
â”‚   â”œâ”€â”€ What_is_SQL/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       SQL (**Structured Query Language**) is a **declarative language** designed to manage and manipulate relational databases.
â”‚   â”‚
â”‚   â”‚       ðŸ”¹ **Key Characteristics:**
â”‚   â”‚       - **Declarative:** You specify *what* data you want, not *how* to retrieve it.
â”‚   â”‚       - Operates on **sets of data**, not row-by-row imperative logic.
â”‚   â”‚       - Standardized by ANSI, with variations across RDBMS vendors.
â”‚   â”‚
â”‚   â”‚       ðŸ”¹ **Core SQL Categories:**
â”‚   â”‚       - **DDL (Data Definition Language):** `CREATE`, `ALTER`, `DROP` (Defines schema)
â”‚   â”‚       - **DML (Data Manipulation Language):** `SELECT`, `INSERT`, `UPDATE`, `DELETE`
â”‚   â”‚       - **DCL (Data Control Language):** `GRANT`, `REVOKE`
â”‚   â”‚       - **TCL (Transaction Control Language):** `COMMIT`, `ROLLBACK`
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       Example Query:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, salary 
â”‚   â”‚       FROM employees 
â”‚   â”‚       WHERE department = 'HR' AND salary > 50000;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       This retrieves employees in HR earning above 50,000.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Why SQL Matters:**
â”‚   â”‚       - Foundation for all relational database interactions.
â”‚   â”‚       - Powers backend systems, reporting tools, and data analytics pipelines.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       **Visualization of SQL Flow:**
â”‚   â”‚       ```
â”‚   â”‚       [Table: employees]
â”‚   â”‚       +----+--------+-------------+--------+
â”‚   â”‚       | ID | Name   | Department  | Salary |
â”‚   â”‚       +----+--------+-------------+--------+
â”‚   â”‚       | 1  | Alice  | HR          | 60000  |
â”‚   â”‚       | 2  | Bob    | IT          | 55000  |
â”‚   â”‚       | 3  | Carol  | HR          | 48000  |
â”‚   â”‚       | 4  | David  | HR          | 70000  |
â”‚   â”‚       +----+--------+-------------+--------+
â”‚   â”‚
â”‚   â”‚       Query Filter:
â”‚   â”‚       WHERE department = 'HR' AND salary > 50000
â”‚   â”‚
â”‚   â”‚       Result:
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | Name   | Salary |
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | Alice  | 60000  |
â”‚   â”‚       | David  | 70000  |
â”‚   â”‚       +--------+--------+
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       **Best Practices:**
â”‚   â”‚       - Always use **WHERE** clauses to avoid full table scans.
â”‚   â”‚       - Use **LIMIT** for large datasets during testing.
â”‚   â”‚       - Format queries for readability, especially joins and subqueries.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ SQL_vs_MySQL_vs_RDBMS/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **SQL**:
â”‚   â”‚       - A **language standard** (Structured Query Language) used to interact with relational databases.
â”‚   â”‚       - Defined by ANSI/ISO, implemented by various database systems.
â”‚   â”‚       - Think of SQL like "English grammar" â€” many people speak it, but with dialects.
â”‚   â”‚
â”‚   â”‚       ðŸ”¹ **MySQL**:
â”‚   â”‚       - A popular **Relational Database Management System (RDBMS)**.
â”‚   â”‚       - Uses SQL as its query language.
â”‚   â”‚       - Open-source (owned by Oracle now), widely used for web applications.
â”‚   â”‚       - Has its own **extensions** to standard SQL (like `LIMIT` keyword).
â”‚   â”‚
â”‚   â”‚       ðŸ”¹ **Other RDBMS**:
â”‚   â”‚       | Feature             | MySQL     | PostgreSQL | OracleDB   | SQL Server |
â”‚   â”‚       |---------------------|-----------|------------|------------|------------|
â”‚   â”‚       | Open Source         | Yes       | Yes        | No         | No         |
â”‚   â”‚       | ACID Compliance     | Good      | Excellent  | Excellent  | Excellent  |
â”‚   â”‚       | JSON Support        | Moderate  | Advanced   | Advanced   | Good       |
â”‚   â”‚       | Best for            | Web Apps  | Complex Queries | Enterprise | Windows Ecosystem |
â”‚   â”‚       | Procedural Language | SQL/PSM   | PL/pgSQL   | PL/SQL     | T-SQL      |
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Key Differences:**
â”‚   â”‚       - **SQL** = Language.
â”‚   â”‚       - **MySQL/PostgreSQL/Oracle** = Software systems that *implement* SQL.
â”‚   â”‚       - Each RDBMS has:
â”‚   â”‚         - Different storage engines.
â”‚   â”‚         - Varying support for advanced features (e.g., partitioning, window functions).
â”‚   â”‚         - Proprietary functions/extensions.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Stick to **ANSI SQL** standards when aiming for portability across databases.
â”‚   â”‚       - Leverage RDBMS-specific features when optimizing for a single platform.
â”‚   â”‚       - For MySQL, understand storage engines (e.g., **InnoDB** vs **MyISAM**).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Common Pitfall:**
â”‚   â”‚       Queries written for MySQL might fail in PostgreSQL due to syntax differences like:
â”‚   â”‚       ```sql
â”‚   â”‚       -- MySQL-specific
â”‚   â”‚       SELECT * FROM employees LIMIT 5 OFFSET 10;
â”‚   â”‚
â”‚   â”‚       -- SQL Server equivalent
â”‚   â”‚       SELECT * FROM employees ORDER BY id OFFSET 10 ROWS FETCH NEXT 5 ROWS ONLY;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ Data_Types_In_MySQL/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       Data types define **what kind of data** can be stored in each column.
â”‚   â”‚       Choosing the right type impacts:
â”‚   â”‚       - **Storage efficiency**
â”‚   â”‚       - **Query performance**
â”‚   â”‚       - **Data integrity**
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Main Categories:**
â”‚   â”‚       1. **Numeric Types**
â”‚   â”‚          - `TINYINT` (1 byte), `SMALLINT`, `INT` (4 bytes), `BIGINT` (8 bytes)
â”‚   â”‚          - `DECIMAL(p,s)` for exact precision (financial data)
â”‚   â”‚          - `FLOAT`, `DOUBLE` for approximate values
â”‚   â”‚
â”‚   â”‚          Example:
â”‚   â”‚          ```sql
â”‚   â”‚          price DECIMAL(10,2)   -- Up to 99999999.99
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       2. **String Types**
â”‚   â”‚          - `CHAR(n)`: Fixed length
â”‚   â”‚          - `VARCHAR(n)`: Variable length
â”‚   â”‚          - `TEXT`, `BLOB`: Large texts/binary data
â”‚   â”‚
â”‚   â”‚          Example:
â”‚   â”‚          ```sql
â”‚   â”‚          name VARCHAR(50)
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       3. **Date and Time Types**
â”‚   â”‚          - `DATE` (YYYY-MM-DD)
â”‚   â”‚          - `DATETIME`, `TIMESTAMP` (timezone-aware)
â”‚   â”‚          - `TIME`, `YEAR`
â”‚   â”‚
â”‚   â”‚          Example:
â”‚   â”‚          ```sql
â”‚   â”‚          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization: Storage Impact**
â”‚   â”‚       | Data Type    | Storage   | Notes                       |
â”‚   â”‚       |--------------|-----------|-----------------------------|
â”‚   â”‚       | INT          | 4 Bytes   | -2B to +2B                  |
â”‚   â”‚       | VARCHAR(100) | Varies    | Actual length + 1 or 2 bytes|
â”‚   â”‚       | DATE         | 3 Bytes   | '1000-01-01' to '9999-12-31'|
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use the **smallest numeric type** that fits your data range.
â”‚   â”‚       - Prefer `VARCHAR` over `TEXT` for searchable columns.
â”‚   â”‚       - Use `DECIMAL` for monetary valuesâ€”**never FLOAT** due to precision errors.
â”‚   â”‚       - Always define appropriate lengths (`VARCHAR(255)` is **not** a default!).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Common Pitfalls:**
â”‚   â”‚       - Oversizing fields â†’ wasted storage & slower indexes.
â”‚   â”‚       - Using `DATETIME` when `DATE` suffices.
â”‚   â”‚       - Forgetting that `TIMESTAMP` auto-converts to UTC.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Example Table Definition:**
â”‚   â”‚       ```sql
â”‚   â”‚       CREATE TABLE orders (
â”‚   â”‚           order_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
â”‚   â”‚           customer_name VARCHAR(100) NOT NULL,
â”‚   â”‚           order_total DECIMAL(10,2),
â”‚   â”‚           order_date DATE
â”‚   â”‚       );
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ NULL_Handling/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **What is NULL?**
â”‚   â”‚       - `NULL` represents **unknown**, **missing**, or **inapplicable** data.
â”‚   â”‚       - It is **NOT**:
â”‚   â”‚         - Zero (`0`)
â”‚   â”‚         - An empty string (`''`)
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Behavior of NULL in SQL:**
â”‚   â”‚       1. **Comparisons Involving NULL:**
â”‚   â”‚          - `NULL = NULL` â†’ **Unknown (NULL)**
â”‚   â”‚          - Use `IS NULL` or `IS NOT NULL` for checks.
â”‚   â”‚
â”‚   â”‚          Example:
â”‚   â”‚          ```sql
â”‚   â”‚          SELECT * FROM employees WHERE manager_id IS NULL;
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       2. **NULL in Expressions:**
â”‚   â”‚          - Any arithmetic or string operation with `NULL` results in `NULL`.
â”‚   â”‚          ```sql
â”‚   â”‚          SELECT salary + NULL  --> NULL
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       3. **Aggregations & NULL:**
â”‚   â”‚          - Functions like `AVG()`, `SUM()`, `COUNT(column)` **ignore NULLs**.
â”‚   â”‚          - But `COUNT(*)` counts all rows.
â”‚   â”‚
â”‚   â”‚          Example:
â”‚   â”‚          ```sql
â”‚   â”‚          SELECT AVG(bonus) FROM salaries;
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Handling NULLs:**
â”‚   â”‚       - Use `COALESCE()` to substitute default values.
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, COALESCE(bonus, 0) AS bonus FROM salaries;
â”‚   â”‚       ```
â”‚   â”‚       This replaces `NULL` bonuses with `0`.
â”‚   â”‚
â”‚   â”‚       - Alternative: `IFNULL()` in MySQL.
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT IFNULL(bonus, 0) FROM salaries;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Common Pitfalls:**
â”‚   â”‚       - Using `=` or `!=` with NULL:
â”‚   â”‚         ```sql
â”‚   â”‚         WHERE bonus = NULL    -- âŒ Incorrect
â”‚   â”‚         WHERE bonus IS NULL   -- âœ… Correct
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚       - Misunderstanding `NOT IN` with NULLs:
â”‚   â”‚         ```sql
â”‚   â”‚         WHERE dept_id NOT IN (1, 2, NULL)  -- Returns no rows!
â”‚   â”‚         ```
â”‚   â”‚         If `NULL` is present in an `IN` list, comparisons become unknown.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Define columns as `NOT NULL` wherever possible.
â”‚   â”‚       - Use default values to minimize unnecessary NULLs.
â”‚   â”‚       - Be explicit in handling NULL logic in queries.
â”‚   â”‚
â”‚   â”‚
â”‚   â””â”€â”€ Schema_Design_Basics/
â”‚       â””â”€â”€ Explanation:
â”‚           ðŸ”¹ **What is Schema Design?**
â”‚           Schema design is the process of structuring your databaseâ€”defining how data is organized, related, and constrained.
â”‚
â”‚           A well-designed schema ensures:
â”‚           - **Data Integrity**
â”‚           - **Performance Optimization**
â”‚           - **Scalability & Maintainability**
â”‚
â”‚           ---
â”‚           ðŸ“Œ **Key Principles:**
â”‚           1. **Normalization** (Eliminate Redundancy)
â”‚              - Apply normal forms (1NF, 2NF, 3NF) to avoid data anomalies.
â”‚              - Example of redundancy:
â”‚              ```
â”‚              Orders Table:
â”‚              +---------+------------+------------+
â”‚              | OrderID | Customer   | CustomerPhone |
â”‚              +---------+------------+------------+
â”‚              |   101   | Alice      | 1234567890   |
â”‚              |   102   | Alice      | 1234567890   |
â”‚              ```
â”‚              Solution: Split into `Customers` and `Orders`.
â”‚
â”‚           2. **Use Proper Data Types**
â”‚              - Optimize storage and enforce correct data formats.
â”‚
â”‚           3. **Define Keys & Relationships**
â”‚              - **Primary Keys**: Uniquely identify records.
â”‚              - **Foreign Keys**: Maintain referential integrity.
â”‚
â”‚           4. **Index Strategically**
â”‚              - Design indexes based on query patterns.
â”‚
â”‚           ---
â”‚           ðŸ”¹ **Example: Basic Schema Design**
â”‚           ```sql
â”‚           CREATE TABLE customers (
â”‚               customer_id INT PRIMARY KEY,
â”‚               name VARCHAR(100) NOT NULL
â”‚           );
â”‚
â”‚           CREATE TABLE orders (
â”‚               order_id INT PRIMARY KEY,
â”‚               customer_id INT,
â”‚               order_date DATE,
â”‚               FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
â”‚           );
â”‚           ```
â”‚
â”‚           ---
â”‚           ðŸš¨ **Common Pitfalls:**
â”‚           - **Over-Normalization** leading to excessive JOINs.
â”‚           - Forgetting to define **constraints**, allowing dirty data.
â”‚           - Using generic data types like `TEXT` or oversized `VARCHAR`.
â”‚
â”‚           ---
â”‚           âœ… **Best Practices:**
â”‚           - Balance **Normalization vs. Performance** (Denormalize where necessary for read-heavy systems).
â”‚           - Always define **Primary Keys**.
â”‚           - Use **naming conventions** for clarity (e.g., `user_id`, `order_id`).
â”‚           - Anticipate growth: avoid hard limits unless justified.
â”‚
â”‚           ---
â”‚           ðŸ“Š **Visualization of Relationships (ERD Concept):**
â”‚           ```
â”‚           customers
â”‚           +-------------+
â”‚           | customer_id |â—„â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           | name        |         â”‚
â”‚           +-------------+         â”‚
â”‚                                   â”‚
â”‚           orders                  â”‚
â”‚           +----------+-------------+
â”‚           | order_id | customer_id â”‚
â”‚           | date     |             â”‚
â”‚           +----------+-------------+
â”‚           ```
â”‚
â”‚
â”œâ”€â”€ Database_Objects/
â”‚   â”œâ”€â”€ Tables/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **What is a Table?**
â”‚   â”‚       - A **Table** is the fundamental storage unit in a relational database.
â”‚   â”‚       - It organizes data into **rows** (records) and **columns** (attributes).
â”‚   â”‚       - Each column has a defined **data type**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Table Structure Example:**
â”‚   â”‚       ```sql
â”‚   â”‚       CREATE TABLE employees (
â”‚   â”‚           emp_id INT PRIMARY KEY,
â”‚   â”‚           name VARCHAR(100) NOT NULL,
â”‚   â”‚           department VARCHAR(50),
â”‚   â”‚           hire_date DATE,
â”‚   â”‚           salary DECIMAL(10,2)
â”‚   â”‚       );
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       This defines:
â”‚   â”‚       - `emp_id` as a unique identifier.
â”‚   â”‚       - `name` must always have a value (`NOT NULL`).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization:**
â”‚   â”‚       employees
â”‚   â”‚       +--------+---------+------------+------------+---------+
â”‚   â”‚       | emp_id | name    | department | hire_date  | salary  |
â”‚   â”‚       +--------+---------+------------+------------+---------+
â”‚   â”‚       |   1    | Alice   | HR         | 2022-01-15 | 60000.00|
â”‚   â”‚       |   2    | Bob     | IT         | 2021-11-20 | 55000.00|
â”‚   â”‚       +--------+---------+------------+------------+---------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Key Operations:**
â”‚   â”‚       - `INSERT INTO`, `SELECT`, `UPDATE`, `DELETE`.
â”‚   â”‚       - Example Insert:
â”‚   â”‚         ```sql
â”‚   â”‚         INSERT INTO employees (emp_id, name, department, hire_date, salary)
â”‚   â”‚         VALUES (3, 'Carol', 'Finance', '2023-03-10', 70000);
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Common Pitfalls:**
â”‚   â”‚       - No Primary Key defined â†’ Leads to duplicate or unidentifiable rows.
â”‚   â”‚       - Poor choice of data types causing storage bloat.
â”‚   â”‚       - Lack of constraints leading to inconsistent data.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Always define a **Primary Key**.
â”‚   â”‚       - Use **appropriate data types** and avoid defaults like `VARCHAR(255)` blindly.
â”‚   â”‚       - Add constraints to enforce business rules.
â”‚   â”‚       - Use **AUTO_INCREMENT** for surrogate keys when natural keys aren't available.
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       CREATE TABLE products (
â”‚   â”‚           product_id INT AUTO_INCREMENT PRIMARY KEY,
â”‚   â”‚           product_name VARCHAR(100) NOT NULL
â”‚   â”‚       );
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ Views/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **What is a View?**
â”‚   â”‚       - A **View** is a **virtual table** based on a SQL query.
â”‚   â”‚       - It doesn't store data physically but presents data dynamically from underlying tables.
â”‚   â”‚       - Useful for:
â”‚   â”‚         - Simplifying complex queries.
â”‚   â”‚         - Enhancing security (restricting column/row access).
â”‚   â”‚         - Providing abstraction layers.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Creating a View:**
â”‚   â”‚       ```sql
â”‚   â”‚       CREATE VIEW active_employees AS
â”‚   â”‚       SELECT emp_id, name, department
â”‚   â”‚       FROM employees
â”‚   â”‚       WHERE status = 'active';
â”‚   â”‚       ```
â”‚   â”‚       - Querying the View:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT * FROM active_employees;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Types of Views:**
â”‚   â”‚       1. **Simple Views** â€“ Based on a single table without functions or GROUP BY.
â”‚   â”‚       2. **Complex Views** â€“ Involve joins, aggregations, functions.
â”‚   â”‚       3. **Updatable Views** â€“ Some views allow `INSERT`, `UPDATE`, `DELETE`.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Limitations:**
â”‚   â”‚       - Views canâ€™t always be updated, especially if:
â”‚   â”‚         - They use `GROUP BY`, `DISTINCT`, `UNION`.
â”‚   â”‚         - They include aggregate functions.
â”‚   â”‚       - Performance: Each query on a view runs the underlying SQL â†’ No "free" optimization unless using **Materialized Views** (not natively in MySQL).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use Views to **encapsulate business logic**.
â”‚   â”‚       - Restrict user access to base tables by granting permissions on Views.
â”‚   â”‚       - Avoid nesting Views within Views in critical paths (can cause performance hits).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Example: Join Simplification via View**
â”‚   â”‚       ```sql
â”‚   â”‚       CREATE VIEW order_summary AS
â”‚   â”‚       SELECT o.order_id, c.name AS customer_name, o.order_total
â”‚   â”‚       FROM orders o
â”‚   â”‚       JOIN customers c ON o.customer_id = c.customer_id;
â”‚   â”‚       ```
â”‚   â”‚       Now, users can:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT * FROM order_summary WHERE order_total > 500;
â”‚   â”‚       ```
â”‚   â”‚       Without knowing the join logic.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ Indexes/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **What is an Index?**
â”‚   â”‚       - An **Index** is a data structure (typically a **B-Tree** in MySQL) that improves the speed of data retrieval.
â”‚   â”‚       - Think of it like a bookâ€™s index â€” it helps you find information without scanning every page.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Types of Indexes in MySQL:**
â”‚   â”‚       1. **Primary Index**:
â”‚   â”‚          - Automatically created on the **Primary Key**.
â”‚   â”‚          - In InnoDB, this is a **Clustered Index**.
â”‚   â”‚
â”‚   â”‚       2. **Secondary (Non-Clustered) Index**:
â”‚   â”‚          - Created on other columns.
â”‚   â”‚          ```sql
â”‚   â”‚          CREATE INDEX idx_name ON employees(name);
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       3. **Unique Index**:
â”‚   â”‚          - Ensures all values are unique.
â”‚   â”‚          ```sql
â”‚   â”‚          CREATE UNIQUE INDEX idx_email ON users(email);
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       4. **Composite Index**:
â”‚   â”‚          - Index on multiple columns.
â”‚   â”‚          ```sql
â”‚   â”‚          CREATE INDEX idx_dept_salary ON employees(department, salary);
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       5. **Full-Text Index** (For text search)
â”‚   â”‚
â”‚   â”‚       6. **Spatial Index** (For GIS data)
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization: How an Index Works**
â”‚   â”‚       Without Index:
â”‚   â”‚       ```
â”‚   â”‚       SELECT * FROM employees WHERE name = 'Alice';
â”‚   â”‚       -- Full Table Scan (O(n))
â”‚   â”‚       ```
â”‚   â”‚       With Index on `name`:
â”‚   â”‚       ```
â”‚   â”‚       -- B-Tree traversal (O(log n))
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Trade-offs:**
â”‚   â”‚       - **Pros**: Speeds up `SELECT`, `WHERE`, `JOIN`, `ORDER BY`.
â”‚   â”‚       - **Cons**: Slows down `INSERT`, `UPDATE`, `DELETE` due to index maintenance.
â”‚   â”‚       - Consumes extra disk space.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Index columns used frequently in:
â”‚   â”‚         - `WHERE` clauses.
â”‚   â”‚         - `JOIN` conditions.
â”‚   â”‚         - `ORDER BY` / `GROUP BY`.
â”‚   â”‚
â”‚   â”‚       - Use **Composite Indexes** wisely â€” order matters!
â”‚   â”‚         - Index `(col1, col2)` supports queries filtering on `col1` or `col1 AND col2`.
â”‚   â”‚         - But **not** on `col2` alone.
â”‚   â”‚
â”‚   â”‚       - Avoid indexing:
â”‚   â”‚         - Columns with low cardinality (e.g., gender).
â”‚   â”‚         - Frequently updated columns.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Example:**
â”‚   â”‚       ```sql
â”‚   â”‚       CREATE INDEX idx_order_date ON orders(order_date);
â”‚   â”‚
â”‚   â”‚       -- Optimized query
â”‚   â”‚       SELECT * FROM orders WHERE order_date >= '2024-01-01';
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ Stored_Procedures/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **What is a Stored Procedure?**
â”‚   â”‚       - A **Stored Procedure** is a precompiled set of SQL statements stored in the database.
â”‚   â”‚       - It allows you to execute complex operations by calling a single procedure.
â”‚   â”‚       - Promotes **code reuse**, **centralized logic**, and **security**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Creating a Stored Procedure:**
â”‚   â”‚       ```sql
â”‚   â”‚       DELIMITER //
â”‚   â”‚       CREATE PROCEDURE GetHighEarners(IN min_salary DECIMAL(10,2))
â”‚   â”‚       BEGIN
â”‚   â”‚           SELECT name, salary FROM employees WHERE salary > min_salary;
â”‚   â”‚       END //
â”‚   â”‚       DELIMITER ;
â”‚   â”‚       ```
â”‚   â”‚       - **Call it**:
â”‚   â”‚       ```sql
â”‚   â”‚       CALL GetHighEarners(60000);
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Parameters:**
â”‚   â”‚       - `IN`  â†’ Input parameter.
â”‚   â”‚       - `OUT` â†’ Output parameter.
â”‚   â”‚       - `INOUT` â†’ Acts as both input and output.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Common Use Cases:**
â”‚   â”‚       - Batch operations.
â”‚   â”‚       - Data validation routines.
â”‚   â”‚       - Complex business logic.
â”‚   â”‚       - Abstracting repetitive queries from applications.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Considerations:**
â”‚   â”‚       - Reduces **network traffic** by bundling operations.
â”‚   â”‚       - BUT, procedural code in SQL (loops, conditionals) can be slower than app-level logic.
â”‚   â”‚       - Harder to scale in distributed architectures (logic locked in DB).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use for **data-centric operations** (where data is heavily involved).
â”‚   â”‚       - Avoid embedding heavy business logicâ€”keep that in application layers.
â”‚   â”‚       - Document procedures well; they can become hidden "black boxes".
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ”¹ **Example with OUT parameter:**
â”‚   â”‚       ```sql
â”‚   â”‚       DELIMITER //
â”‚   â”‚       CREATE PROCEDURE CountEmployees(OUT emp_count INT)
â”‚   â”‚       BEGIN
â”‚   â”‚           SELECT COUNT(*) INTO emp_count FROM employees;
â”‚   â”‚       END //
â”‚   â”‚       DELIMITER ;
â”‚   â”‚
â”‚   â”‚       CALL CountEmployees(@total);
â”‚   â”‚       SELECT @total;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚
â”‚   â””â”€â”€ Constraints/
â”‚       â”œâ”€â”€ Primary_Key/
â”‚       â”‚   â””â”€â”€ Explanation:
â”‚       â”‚       - A **Primary Key (PK)** uniquely identifies each row in a table.
â”‚       â”‚       - It is **NOT NULL** and **UNIQUE** by definition.
â”‚       â”‚       - A table can have **only one** PK (can be single or multi-column).
â”‚       â”‚
â”‚       â”‚       Example (Single-column PK):
â”‚       â”‚       ```sql
â”‚       â”‚       CREATE TABLE customers (
â”‚       â”‚           customer_id INT PRIMARY KEY,
â”‚       â”‚           name VARCHAR(100)
â”‚       â”‚       );
â”‚       â”‚       ```
â”‚       â”‚
â”‚       â”‚       Example (Composite PK):
â”‚       â”‚       ```sql
â”‚       â”‚       CREATE TABLE enrollments (
â”‚       â”‚           student_id INT,
â”‚       â”‚           course_id INT,
â”‚       â”‚           PRIMARY KEY (student_id, course_id)
â”‚       â”‚       );
â”‚       â”‚       ```
â”‚       â”‚
â”‚       â”‚       âœ… **Best Practices:**
â”‚       â”‚       - Use **surrogate keys** (`AUTO_INCREMENT`) when natural keys are too complex.
â”‚       â”‚       - Keep composite keys minimal to avoid large index overhead.
â”‚       â”‚
â”‚       â”œâ”€â”€ Foreign_Key/
â”‚       â”‚   â””â”€â”€ Explanation:
â”‚       â”‚       - A **Foreign Key (FK)** enforces referential integrity between tables.
â”‚       â”‚       - Links a column in one table to the **Primary Key** in another.
â”‚       â”‚
â”‚       â”‚       Example:
â”‚       â”‚       ```sql
â”‚       â”‚       CREATE TABLE orders (
â”‚       â”‚           order_id INT PRIMARY KEY,
â”‚       â”‚           customer_id INT,
â”‚       â”‚           FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
â”‚       â”‚       );
â”‚       â”‚       ```
â”‚       â”‚
â”‚       â”‚       ðŸ”¹ **Cascading Actions**:
â”‚       â”‚       ```sql
â”‚       â”‚       FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
â”‚       â”‚       ON DELETE CASCADE
â”‚       â”‚       ON UPDATE CASCADE
â”‚       â”‚       ```
â”‚       â”‚       - `CASCADE`: Propagates changes.
â”‚       â”‚       - `SET NULL`: Sets FK to NULL.
â”‚       â”‚       - `RESTRICT` / `NO ACTION`: Prevents the change.
â”‚       â”‚
â”‚       â”‚       ðŸš¨ **Pitfall:** Be cautious with `ON DELETE CASCADE` in production systems!
â”‚       â”‚
â”‚       â”œâ”€â”€ Unique/
â”‚       â”‚   â””â”€â”€ Explanation:
â”‚       â”‚       - Ensures all values in a column (or group of columns) are **unique**.
â”‚       â”‚       - Unlike PK, allows **multiple NULLs**.
â”‚       â”‚
â”‚       â”‚       Example:
â”‚       â”‚       ```sql
â”‚       â”‚       CREATE TABLE users (
â”‚       â”‚           user_id INT PRIMARY KEY,
â”‚       â”‚           email VARCHAR(100),
â”‚       â”‚           UNIQUE (email)
â”‚       â”‚       );
â”‚       â”‚       ```
â”‚       â”‚
â”‚       â”‚       ðŸ”¹ Composite UNIQUE:
â”‚       â”‚       ```sql
â”‚       â”‚       UNIQUE (first_name, last_name)
â”‚       â”‚       ```
â”‚       â”‚
â”‚       â”œâ”€â”€ Check/
â”‚       â”‚   â””â”€â”€ Explanation:
â”‚       â”‚       - Restricts values based on a condition.
â”‚       â”‚       - Enforced at the row level during `INSERT` or `UPDATE`.
â”‚       â”‚
â”‚       â”‚       Example:
â”‚       â”‚       ```sql
â”‚       â”‚       CREATE TABLE employees (
â”‚       â”‚           emp_id INT PRIMARY KEY,
â”‚       â”‚           salary DECIMAL(10,2),
â”‚       â”‚           CHECK (salary >= 15000)
â”‚       â”‚       );
â”‚       â”‚       ```
â”‚       â”‚
â”‚       â”‚       ðŸ”¹ Advanced Example:
â”‚       â”‚       ```sql
â”‚       â”‚       CHECK (end_date > start_date)
â”‚       â”‚       ```
â”‚       â”‚
â”‚       â”‚       ðŸš¨ Note: MySQL enforced `CHECK` constraints only from version 8.0+.
â”‚       â”‚
â”‚       â””â”€â”€ Default/
â”‚           â””â”€â”€ Explanation:
â”‚               - Sets a **default value** when no explicit value is provided.
â”‚
â”‚               Example:
â”‚               ```sql
â”‚               CREATE TABLE products (
â”‚                   product_id INT PRIMARY KEY,
â”‚                   stock INT DEFAULT 0
â”‚               );
â”‚
â”‚               INSERT INTO products (product_id) VALUES (1);
â”‚               -- stock will be 0 by default
â”‚               ```
â”‚
â”‚               âœ… Best Practices:
â”‚               - Use defaults to avoid NULLs where applicable.
â”‚               - For timestamps:
â”‚               ```sql
â”‚               created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
â”‚               ```
â”‚
â”‚
â”œâ”€â”€ SELECT_Statement/
â”‚   â”œâ”€â”€ Basic_SELECT/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Retrieve data from one or more tables.
â”‚   â”‚       - The `SELECT` statement defines **which columns** to fetch.
â”‚   â”‚       - By default, it returns **all matching rows** unless filtered.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT column1, column2, ...
â”‚   â”‚       FROM table_name;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, department FROM employees;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       - Use `SELECT *` to fetch **all columns**, but:
â”‚   â”‚         ðŸš¨ **Avoid `SELECT *` in production** â€” itâ€™s inefficient and can break apps if schema changes.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       Table: employees
â”‚   â”‚       +----+--------+------------+--------+
â”‚   â”‚       | id | name   | department | salary |
â”‚   â”‚       +----+--------+------------+--------+
â”‚   â”‚       | 1  | Alice  | HR         | 60000  |
â”‚   â”‚       | 2  | Bob    | IT         | 55000  |
â”‚   â”‚       +----+--------+------------+--------+
â”‚   â”‚
â”‚   â”‚       Query:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, salary FROM employees;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       Result:
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | name   | salary |
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | Alice  | 60000  |
â”‚   â”‚       | Bob    | 55000  |
â”‚   â”‚       +--------+--------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Always specify required columns.
â”‚   â”‚       - Alias columns for clarity:
â”‚   â”‚         ```sql
â”‚   â”‚         SELECT name AS employee_name FROM employees;
â”‚   â”‚         ```
â”‚   â”‚       - Use consistent formatting for readability.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Common Pitfalls:**
â”‚   â”‚       - Forgetting the `FROM` clause (applies in some DBs, but not standard SQL).
â”‚   â”‚       - Using `SELECT *` leading to:
â”‚   â”‚         - Increased network load.
â”‚   â”‚         - Unused data fetched.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ SELECT_DISTINCT/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Eliminate **duplicate rows** from the result set.
â”‚   â”‚       - `DISTINCT` applies to **all selected columns** as a group.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT DISTINCT column1, column2
â”‚   â”‚       FROM table_name;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT DISTINCT department FROM employees;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       employees table:
â”‚   â”‚       +----+--------+------------+
â”‚   â”‚       | id | name   | department |
â”‚   â”‚       +----+--------+------------+
â”‚   â”‚       | 1  | Alice  | HR         |
â”‚   â”‚       | 2  | Bob    | IT         |
â”‚   â”‚       | 3  | Carol  | HR         |
â”‚   â”‚
â”‚   â”‚       Query:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT DISTINCT department FROM employees;
â”‚   â”‚       ```
â”‚   â”‚       Result:
â”‚   â”‚       +------------+
â”‚   â”‚       | department |
â”‚   â”‚       +------------+
â”‚   â”‚       | HR         |
â”‚   â”‚       | IT         |
â”‚   â”‚       +------------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - `DISTINCT` applies to the **combination** of columns:
â”‚   â”‚         ```sql
â”‚   â”‚         SELECT DISTINCT department, name FROM employees;
â”‚   â”‚         ```
â”‚   â”‚         This only removes rows where **both** columns are identical.
â”‚   â”‚
â”‚   â”‚       - Internally, MySQL performs a **sort** or uses a **temporary table** â†’ Can impact performance on large datasets.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Only use `DISTINCT` when truly needed â€” avoid as a lazy fix for bad joins or poor data modeling.
â”‚   â”‚       - For counting unique values:
â”‚   â”‚         ```sql
â”‚   â”‚         SELECT COUNT(DISTINCT department) FROM employees;
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Alternative Techniques:**
â”‚   â”‚       - Use `GROUP BY` when you also want aggregations.
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT department FROM employees GROUP BY department;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ SELECT_with_WHERE/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Filter rows based on specified conditions.
â”‚   â”‚       - The `WHERE` clause restricts the result set to rows that meet the condition(s).
â”‚   â”‚       - It operates **before** grouping, ordering, or limiting results.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT column1, column2
â”‚   â”‚       FROM table_name
â”‚   â”‚       WHERE condition;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, salary
â”‚   â”‚       FROM employees
â”‚   â”‚       WHERE department = 'IT' AND salary > 50000;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       employees table:
â”‚   â”‚       +----+--------+------------+--------+
â”‚   â”‚       | id | name   | department | salary |
â”‚   â”‚       +----+--------+------------+--------+
â”‚   â”‚       | 1  | Alice  | HR         | 60000  |
â”‚   â”‚       | 2  | Bob    | IT         | 55000  |
â”‚   â”‚       | 3  | Carol  | IT         | 48000  |
â”‚   â”‚
â”‚   â”‚       Query Result:
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | name   | salary |
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | Bob    | 55000  |
â”‚   â”‚       +--------+--------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - String comparisons are **case-insensitive** by default in MySQL (`latin1` / `utf8_general_ci` collations).
â”‚   â”‚       - Use quotes `'value'` for string literals.
â”‚   â”‚       - Combine conditions using `AND`, `OR`, `NOT`.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use indexed columns in `WHERE` for better performance.
â”‚   â”‚       - Watch out for:
â”‚   â”‚         ```sql
â”‚   â”‚         WHERE column = NULL   -- âŒ Incorrect
â”‚   â”‚         WHERE column IS NULL  -- âœ… Correct
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚       - Use parentheses to control logic flow:
â”‚   â”‚         ```sql
â”‚   â”‚         WHERE (dept = 'HR' OR dept = 'IT') AND salary > 50000
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Alternative Techniques:**
â”‚   â”‚       - Use `BETWEEN`, `IN`, `LIKE` for flexible filtering (covered in detail under `WHERE_Clauses/`).
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ SELECT_with_ORDER_BY/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Sort the result set by one or more columns.
â”‚   â”‚       - By default, `ORDER BY` sorts in **ascending (ASC)** order.
â”‚   â”‚       - You can specify **DESC** for descending order.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT column1, column2
â”‚   â”‚       FROM table_name
â”‚   â”‚       ORDER BY column1 [ASC|DESC], column2 [ASC|DESC];
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, salary
â”‚   â”‚       FROM employees
â”‚   â”‚       ORDER BY salary DESC;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       employees table:
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | name   | salary |
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | Alice  | 60000  |
â”‚   â”‚       | Bob    | 55000  |
â”‚   â”‚       | Carol  | 48000  |
â”‚   â”‚
â”‚   â”‚       After `ORDER BY salary DESC`:
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | name   | salary |
â”‚   â”‚       +--------+--------+
â”‚   â”‚       | Alice  | 60000  |
â”‚   â”‚       | Bob    | 55000  |
â”‚   â”‚       | Carol  | 48000  |
â”‚   â”‚       +--------+--------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - You can order by:
â”‚   â”‚         - **Column names**
â”‚   â”‚         - **Column positions** (not recommended for clarity)
â”‚   â”‚         ```sql
â”‚   â”‚         ORDER BY 2 DESC  -- Sorts by second selected column
â”‚   â”‚         ```
â”‚   â”‚       - `NULL` values by default:
â”‚   â”‚         - In MySQL, `NULL` appears **first** in ASC, **last** in DESC.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Always be explicit with `ASC` or `DESC` for readability.
â”‚   â”‚       - Use `ORDER BY` **after** filtering (`WHERE`), but **before** `LIMIT`.
â”‚   â”‚       - For stable sorting, include secondary columns:
â”‚   â”‚         ```sql
â”‚   â”‚         ORDER BY salary DESC, name ASC
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tips:**
â”‚   â”‚       - Sorting is resource-intensiveâ€”use indexes to optimize `ORDER BY` where possible.
â”‚   â”‚       - Avoid `ORDER BY` on calculated fields without necessity.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ SELECT_with_LIMIT_and_OFFSET/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Restrict the number of rows returned by a query.
â”‚   â”‚       - `LIMIT` defines **how many rows** to return.
â”‚   â”‚       - `OFFSET` defines **where to start** returning rows (used for pagination).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT column1, column2
â”‚   â”‚       FROM table_name
â”‚   â”‚       ORDER BY column1
â”‚   â”‚       LIMIT number_of_rows OFFSET start_point;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ðŸ”¹ Shortcut Syntax:
â”‚   â”‚       ```sql
â”‚   â”‚       LIMIT start_point, number_of_rows
â”‚   â”‚       ```
â”‚   â”‚       Example (get 5 rows starting from 11th row):
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT * FROM employees
â”‚   â”‚       ORDER BY emp_id
â”‚   â”‚       LIMIT 10, 5;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       Assume ordered employee IDs:
â”‚   â”‚       +--------+
â”‚   â”‚       | emp_id |
â”‚   â”‚       +--------+
â”‚   â”‚       |   1    |
â”‚   â”‚       |   2    |
â”‚   â”‚       |  ...   |
â”‚   â”‚       |  10    |
â”‚   â”‚       |  11    |  â—„â”€â”€ Start here (OFFSET 10)
â”‚   â”‚       |  12    |
â”‚   â”‚       |  13    |
â”‚   â”‚       |  14    |
â”‚   â”‚       |  15    |
â”‚   â”‚       +--------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - `LIMIT` without `ORDER BY` returns **arbitrary rows** (no guaranteed order).
â”‚   â”‚       - `OFFSET` starts counting from **zero**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Always pair `LIMIT` with `ORDER BY` for predictable results.
â”‚   â”‚       - For large offsets (deep pagination), performance degradesâ€”consider "keyset pagination" as an alternative.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Example: Pagination Query**
â”‚   â”‚       ```sql
â”‚   â”‚       -- Page 2, 10 rows per page
â”‚   â”‚       SELECT * FROM products
â”‚   â”‚       ORDER BY product_id
â”‚   â”‚       LIMIT 10 OFFSET 10;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ SELECT_with_GROUP_BY_and_HAVING/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**:
â”‚   â”‚       - `GROUP BY` groups rows sharing a value into summary rows.
â”‚   â”‚       - Typically used with **aggregate functions** (`COUNT`, `SUM`, etc.).
â”‚   â”‚       - `HAVING` filters groups **after aggregation** (whereas `WHERE` filters rows **before grouping**).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT column1, AGG_FUNC(column2)
â”‚   â”‚       FROM table_name
â”‚   â”‚       WHERE condition
â”‚   â”‚       GROUP BY column1
â”‚   â”‚       HAVING aggregate_condition
â”‚   â”‚       ORDER BY column1;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT department, COUNT(*) AS emp_count
â”‚   â”‚       FROM employees
â”‚   â”‚       GROUP BY department
â”‚   â”‚       HAVING emp_count > 5;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       employees table:
â”‚   â”‚       +--------+------------+
â”‚   â”‚       | name   | department |
â”‚   â”‚       +--------+------------+
â”‚   â”‚       | Alice  | HR         |
â”‚   â”‚       | Bob    | IT         |
â”‚   â”‚       | Carol  | HR         |
â”‚   â”‚       | Dave   | IT         |
â”‚   â”‚       | Emma   | HR         |
â”‚   â”‚
â”‚   â”‚       After `GROUP BY department`:
â”‚   â”‚       +------------+-----------+
â”‚   â”‚       | department | emp_count |
â”‚   â”‚       +------------+-----------+
â”‚   â”‚       | HR         |     3     |
â”‚   â”‚       | IT         |     2     |
â”‚   â”‚       +------------+-----------+
â”‚   â”‚
â”‚   â”‚       Apply `HAVING emp_count > 2`:
â”‚   â”‚       +------------+-----------+
â”‚   â”‚       | HR         |     3     |
â”‚   â”‚       +------------+-----------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - Every non-aggregated column in `SELECT` **must appear** in `GROUP BY`.
â”‚   â”‚       - `HAVING` works **after** aggregation â€” donâ€™t confuse it with `WHERE`.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use `WHERE` to reduce dataset **before** grouping for better performance.
â”‚   â”‚       - Alias aggregated columns for readability (`AS` keyword).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Example: Filter Before and After**
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT department, AVG(salary) AS avg_sal
â”‚   â”‚       FROM employees
â”‚   â”‚       WHERE salary > 40000
â”‚   â”‚       GROUP BY department
â”‚   â”‚       HAVING avg_sal > 50000;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚
â”œâ”€â”€ WHERE_Clauses/
â”‚   â”œâ”€â”€ Operators/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Operators define conditions in `WHERE` clauses to filter data.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Common Operators in SQL:**
â”‚   â”‚       1. `=` : **Equals**
â”‚   â”‚          ```sql
â”‚   â”‚          WHERE department = 'IT'
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       2. `<>` or `!=` : **Not Equal**
â”‚   â”‚          ```sql
â”‚   â”‚          WHERE salary <> 50000
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       3. `BETWEEN ... AND ...` : **Range Filter (Inclusive)**
â”‚   â”‚          ```sql
â”‚   â”‚          WHERE salary BETWEEN 40000 AND 60000
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       4. `LIKE` : **Pattern Matching**
â”‚   â”‚          - `%` = any sequence of characters
â”‚   â”‚          - `_` = single character
â”‚   â”‚          ```sql
â”‚   â”‚          WHERE name LIKE 'A%'
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       5. `IN` : **Match from a List**
â”‚   â”‚          ```sql
â”‚   â”‚          WHERE department IN ('HR', 'IT')
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       6. `IS NULL` / `IS NOT NULL` : **Null Checks**
â”‚   â”‚          ```sql
â”‚   â”‚          WHERE manager_id IS NULL
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization Example**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT * FROM employees
â”‚   â”‚       WHERE salary BETWEEN 50000 AND 70000
â”‚   â”‚             AND department IN ('HR', 'Finance');
â”‚   â”‚       ```
â”‚   â”‚       - Filters employees in HR/Finance earning within the specified range.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - `BETWEEN` is **inclusive** (includes boundary values).
â”‚   â”‚       - `LIKE 'A%'` is **case-insensitive** by default in MySQL unless collation is changed.
â”‚   â”‚       - `IN` with a large list may degrade performance â€” consider using a join with a lookup table.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - For patterns, avoid starting `LIKE` with `%`:
â”‚   â”‚         ```sql
â”‚   â”‚         WHERE name LIKE '%son'   -- âŒ Prevents index usage
â”‚   â”‚         WHERE name LIKE 'A%'     -- âœ… Index-friendly
â”‚   â”‚         ```
â”‚   â”‚       - Use `IS NULL` properly â€” never use `= NULL`.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Alternative:**
â”‚   â”‚       - Replace multiple `OR` conditions with `IN` for cleaner syntax:
â”‚   â”‚         ```sql
â”‚   â”‚         WHERE dept = 'HR' OR dept = 'IT' OR dept = 'Finance'
â”‚   â”‚         -- becomes
â”‚   â”‚         WHERE dept IN ('HR', 'IT', 'Finance')
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ Logical_Operators/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Combine multiple conditions in a `WHERE` clause.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Logical Operators:**
â”‚   â”‚       1. **`AND`** â€” All conditions must be true.
â”‚   â”‚          ```sql
â”‚   â”‚          WHERE department = 'IT' AND salary > 50000
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       2. **`OR`** â€” At least one condition must be true.
â”‚   â”‚          ```sql
â”‚   â”‚          WHERE department = 'HR' OR department = 'Finance'
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       3. **`NOT`** â€” Negates a condition.
â”‚   â”‚          ```sql
â”‚   â”‚          WHERE NOT (department = 'HR')
â”‚   â”‚          ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization of Condition Logic**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT * FROM employees
â”‚   â”‚       WHERE department = 'IT'
â”‚   â”‚         AND salary BETWEEN 50000 AND 70000
â”‚   â”‚         OR department = 'HR';
â”‚   â”‚       ```
â”‚   â”‚       âš ï¸ Without parentheses, this evaluates as:
â”‚   â”‚       ```
â”‚   â”‚       (department = 'IT' AND salary BETWEEN 50k AND 70k)
â”‚   â”‚       OR
â”‚   â”‚       (department = 'HR')
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - `AND` has **higher precedence** than `OR`.
â”‚   â”‚       - Always use **parentheses** `()` to make logic explicit and avoid surprises.
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       WHERE (department = 'IT' OR department = 'HR')
â”‚   â”‚         AND salary > 50000
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use parentheses to clarify complex conditions.
â”‚   â”‚       - Avoid overusing `NOT` â€” it can confuse logic and sometimes block index usage.
â”‚   â”‚       - Rewrite negative logic where possible:
â”‚   â”‚         ```sql
â”‚   â”‚         WHERE NOT (salary BETWEEN 40000 AND 60000)
â”‚   â”‚         -- Better as:
â”‚   â”‚         WHERE salary < 40000 OR salary > 60000
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - Place the most **selective conditions first** when using `AND` (though modern optimizers handle this, it helps readability).
â”‚   â”‚
â”‚   â”‚
â”œâ”€â”€ JOINS/
â”‚   â”œâ”€â”€ INNER_JOIN/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Retrieve records with **matching values** in both tables.
â”‚   â”‚       - The most common type of join.
â”‚   â”‚       - Returns rows **only where the join condition is true**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT a.column1, b.column2
â”‚   â”‚       FROM tableA a
â”‚   â”‚       INNER JOIN tableB b
â”‚   â”‚       ON a.common_field = b.common_field;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT employees.name, departments.dept_name
â”‚   â”‚       FROM employees
â”‚   â”‚       INNER JOIN departments
â”‚   â”‚       ON employees.dept_id = departments.dept_id;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       **employees**
â”‚   â”‚       +----+--------+---------+
â”‚   â”‚       | id | name   | dept_id |
â”‚   â”‚       +----+--------+---------+
â”‚   â”‚       | 1  | Alice  |   10    |
â”‚   â”‚       | 2  | Bob    |   20    |
â”‚   â”‚
â”‚   â”‚       **departments**
â”‚   â”‚       +---------+------------+
â”‚   â”‚       | dept_id | dept_name  |
â”‚   â”‚       +---------+------------+
â”‚   â”‚       |   10    | HR         |
â”‚   â”‚       |   30    | Finance    |
â”‚   â”‚
â”‚   â”‚       Result of INNER JOIN:
â”‚   â”‚       +--------+------------+
â”‚   â”‚       | name   | dept_name  |
â”‚   â”‚       +--------+------------+
â”‚   â”‚       | Alice  | HR         |
â”‚   â”‚       +--------+------------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - If no match is found in either table, that row is **excluded**.
â”‚   â”‚       - `INNER JOIN` is equivalent to:
â”‚   â”‚         ```sql
â”‚   â”‚         FROM tableA a, tableB b
â”‚   â”‚         WHERE a.id = b.id
â”‚   â”‚         ```
â”‚   â”‚         But explicit `JOIN` syntax is clearer and preferred.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Always use **ON** for clear join conditions.
â”‚   â”‚       - Qualify column names (`table.column`) to avoid ambiguity.
â”‚   â”‚       - Ensure join fields are indexed for performance.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - Watch for accidental **Cartesian products** when missing join conditions.
â”‚   â”‚       - Use `EXPLAIN` to analyze join execution plans.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ LEFT_JOIN/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Return **all rows** from the **left table**, and matched rows from the right table.
â”‚   â”‚       - If thereâ€™s no match, columns from the right table return **NULL**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT a.column1, b.column2
â”‚   â”‚       FROM tableA a
â”‚   â”‚       LEFT JOIN tableB b
â”‚   â”‚       ON a.common_field = b.common_field;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT employees.name, departments.dept_name
â”‚   â”‚       FROM employees
â”‚   â”‚       LEFT JOIN departments
â”‚   â”‚       ON employees.dept_id = departments.dept_id;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       **employees**
â”‚   â”‚       +----+--------+---------+
â”‚   â”‚       | id | name   | dept_id |
â”‚   â”‚       +----+--------+---------+
â”‚   â”‚       | 1  | Alice  |   10    |
â”‚   â”‚       | 2  | Bob    |   20    |
â”‚   â”‚
â”‚   â”‚       **departments**
â”‚   â”‚       +---------+------------+
â”‚   â”‚       | dept_id | dept_name  |
â”‚   â”‚       +---------+------------+
â”‚   â”‚       |   10    | HR         |
â”‚   â”‚
â”‚   â”‚       Result of LEFT JOIN:
â”‚   â”‚       +--------+------------+
â”‚   â”‚       | name   | dept_name  |
â”‚   â”‚       +--------+------------+
â”‚   â”‚       | Alice  | HR         |
â”‚   â”‚       | Bob    | NULL       |
â”‚   â”‚       +--------+------------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - Always remember: LEFT JOIN = **All Left + Matched Right**.
â”‚   â”‚       - Use `IS NULL` to detect **unmatched rows**:
â”‚   â”‚         ```sql
â”‚   â”‚         WHERE departments.dept_id IS NULL
â”‚   â”‚         ```
â”‚   â”‚         This finds "orphans" â€” rows with no match.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use LEFT JOIN when you need a **complete list** from the primary table, regardless of relationships.
â”‚   â”‚       - Filter carefully â€” applying conditions on the right table can accidentally turn a LEFT JOIN into an INNER JOIN if not handled properly.
â”‚   â”‚
â”‚   â”‚       Example (correct way to filter right table conditionally):
â”‚   â”‚       ```sql
â”‚   â”‚       WHERE departments.dept_name = 'HR' OR departments.dept_name IS NULL
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - Ensure join columns are indexed, especially in large datasets.
â”‚   â”‚       - Avoid unnecessary LEFT JOINs if an INNER JOIN suffices â€” they are heavier.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ RIGHT_JOIN/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Return **all rows** from the **right table**, and matched rows from the left table.
â”‚   â”‚       - If thereâ€™s no match, columns from the left table return **NULL**.
â”‚   â”‚       - Less commonly used than `LEFT JOIN` but functionally identical if you reverse table order.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT a.column1, b.column2
â”‚   â”‚       FROM tableA a
â”‚   â”‚       RIGHT JOIN tableB b
â”‚   â”‚       ON a.common_field = b.common_field;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT employees.name, departments.dept_name
â”‚   â”‚       FROM employees
â”‚   â”‚       RIGHT JOIN departments
â”‚   â”‚       ON employees.dept_id = departments.dept_id;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       **employees**
â”‚   â”‚       +----+--------+---------+
â”‚   â”‚       | id | name   | dept_id |
â”‚   â”‚       +----+--------+---------+
â”‚   â”‚       | 1  | Alice  |   10    |
â”‚   â”‚
â”‚   â”‚       **departments**
â”‚   â”‚       +---------+------------+
â”‚   â”‚       | dept_id | dept_name  |
â”‚   â”‚       +---------+------------+
â”‚   â”‚       |   10    | HR         |
â”‚   â”‚       |   20    | IT         |
â”‚   â”‚
â”‚   â”‚       Result of RIGHT JOIN:
â”‚   â”‚       +--------+------------+
â”‚   â”‚       | name   | dept_name  |
â”‚   â”‚       +--------+------------+
â”‚   â”‚       | Alice  | HR         |
â”‚   â”‚       | NULL   | IT         |
â”‚   â”‚       +--------+------------+
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - RIGHT JOIN is rarely necessary â€” you can rewrite it as a `LEFT JOIN` by swapping tables.
â”‚   â”‚
â”‚   â”‚       Equivalent:
â”‚   â”‚       ```sql
â”‚   â”‚       A RIGHT JOIN B  â‰¡  B LEFT JOIN A
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Prefer `LEFT JOIN` for readability and consistency unless logic dictates otherwise.
â”‚   â”‚       - Use `IS NULL` checks to identify non-matching left table entries.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - Same optimization rules as LEFT JOIN â€” index your join keys.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ FULL_OUTER_JOIN_and_Workaround/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: 
â”‚   â”‚       - A **FULL OUTER JOIN** returns:
â”‚   â”‚         - All matching rows from both tables (**like INNER JOIN**).
â”‚   â”‚         - Plus **unmatched rows** from both the left and right tables, filling gaps with `NULL`.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Standard SQL Syntax** (âŒ Not supported in MySQL):
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT *
â”‚   â”‚       FROM tableA
â”‚   â”‚       FULL OUTER JOIN tableB
â”‚   â”‚       ON tableA.id = tableB.id;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **MySQL Workaround**:
â”‚   â”‚       - Simulate FULL OUTER JOIN using `UNION` of `LEFT JOIN` and `RIGHT JOIN`.
â”‚   â”‚
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT a.id, a.col1, b.col2
â”‚   â”‚       FROM tableA a
â”‚   â”‚       LEFT JOIN tableB b ON a.id = b.id
â”‚   â”‚
â”‚   â”‚       UNION
â”‚   â”‚
â”‚   â”‚       SELECT a.id, a.col1, b.col2
â”‚   â”‚       FROM tableA a
â”‚   â”‚       RIGHT JOIN tableB b ON a.id = b.id;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       - `UNION` removes duplicates automatically.
â”‚   â”‚       - If you want to **keep duplicates**, use `UNION ALL`.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       ```
â”‚   â”‚       Result = (Matched Rows)
â”‚   â”‚              + (Unmatched Left Rows)
â”‚   â”‚              + (Unmatched Right Rows)
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - If possible, **rethink schema or query logic** to avoid FULL OUTER JOIN in MySQL.
â”‚   â”‚       - Use `COALESCE()` to handle `NULL` values gracefully in results:
â”‚   â”‚         ```sql
â”‚   â”‚         SELECT COALESCE(a.id, b.id) AS id, ...
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - This workaround runs **two joins**, so itâ€™s heavier than standard joins.
â”‚   â”‚       - Ensure proper indexing on join keys to minimize performance hit.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ CROSS_JOIN/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: 
â”‚   â”‚       - A **CROSS JOIN** returns the **Cartesian product** of two tables.
â”‚   â”‚       - Every row from the first table is paired with **every row** from the second table.
â”‚   â”‚       - Typically used when **all combinations** are needed.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT *
â”‚   â”‚       FROM tableA
â”‚   â”‚       CROSS JOIN tableB;
â”‚   â”‚       ```
â”‚   â”‚       - Alternatively (implicit syntax, but risky):
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT *
â”‚   â”‚       FROM tableA, tableB;
â”‚   â”‚       ```
â”‚   â”‚       âš ï¸ Without a `WHERE` clause, this behaves like a CROSS JOIN.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       Table A (2 rows)      Table B (3 rows)
â”‚   â”‚       +----+--------+       +----+-------+
â”‚   â”‚       | id | Name   |       | id | Color |
â”‚   â”‚       +----+--------+       +----+-------+
â”‚   â”‚       | 1  | Alice  |       | 1  | Red   |
â”‚   â”‚       | 2  | Bob    |       | 2  | Blue  |
â”‚   â”‚                           +  | 3  | Green |
â”‚   â”‚
â”‚   â”‚       Result: 2 x 3 = **6 rows**
â”‚   â”‚       +--------+-------+
â”‚   â”‚       | Name   | Color |
â”‚   â”‚       +--------+-------+
â”‚   â”‚       | Alice  | Red   |
â”‚   â”‚       | Alice  | Blue  |
â”‚   â”‚       | Alice  | Green |
â”‚   â”‚       | Bob    | Red   |
â”‚   â”‚       | Bob    | Blue  |
â”‚   â”‚       | Bob    | Green |
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - Be cautious â€” output size = rows_in_A * rows_in_B.
â”‚   â”‚       - Accidental Cartesian products often happen by forgetting join conditions in regular joins.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use CROSS JOIN **only** when you explicitly need combinations (e.g., generating schedules, pairing datasets).
â”‚   â”‚       - For readability, prefer explicit `CROSS JOIN` over comma joins.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Performance Tip:**
â”‚   â”‚       - Always estimate row counts before running CROSS JOINs on large tables to avoid crashes or long executions.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ Self_Join/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: 
â”‚   â”‚       - A **Self Join** is when a table is joined **to itself**.
â”‚   â”‚       - Useful for:
â”‚   â”‚         - Hierarchical data (e.g., employees & managers).
â”‚   â”‚         - Comparing rows within the same table.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax**:
â”‚   â”‚       - You must use **table aliases** to differentiate instances.
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT e1.name AS Employee, e2.name AS Manager
â”‚   â”‚       FROM employees e1
â”‚   â”‚       LEFT JOIN employees e2
â”‚   â”‚       ON e1.manager_id = e2.emp_id;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       employees table:
â”‚   â”‚       +--------+-----------+------------+
â”‚   â”‚       | emp_id | name      | manager_id |
â”‚   â”‚       +--------+-----------+------------+
â”‚   â”‚       |   1    | Alice     |   NULL     |
â”‚   â”‚       |   2    | Bob       |     1      |
â”‚   â”‚       |   3    | Carol     |     1      |
â”‚   â”‚       |   4    | Dave      |     2      |
â”‚   â”‚
â”‚   â”‚       Result:
â”‚   â”‚       +----------+-----------+
â”‚   â”‚       | Employee | Manager   |
â”‚   â”‚       +----------+-----------+
â”‚   â”‚       | Alice    | NULL      |
â”‚   â”‚       | Bob      | Alice     |
â”‚   â”‚       | Carol    | Alice     |
â”‚   â”‚       | Dave     | Bob       |
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - Always alias tables in self joins to avoid ambiguity.
â”‚   â”‚       - Use `LEFT JOIN` if you want to include top-level entities (like employees without managers).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Clearly name aliases (`parent`, `child`, `e1`, `e2`) to reflect relationships.
â”‚   â”‚       - Ensure proper indexing on the columns used for self-referencing (like `manager_id`).
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Use Cases:**
â”‚   â”‚       - Organizational charts.
â”‚   â”‚       - Product categories & subcategories.
â”‚   â”‚       - Detecting duplicates or comparing row values within the same table.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ JOIN_Conditions_ON_vs_USING/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **Purpose**: Define how tables are linked in JOIN operations.
â”‚   â”‚
â”‚   â”‚       There are two main ways to specify join conditions:
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **1. Using `ON` Clause**:
â”‚   â”‚       - Most flexible.
â”‚   â”‚       - Allows joining on different column names or complex conditions.
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT e.name, d.dept_name
â”‚   â”‚       FROM employees e
â”‚   â”‚       JOIN departments d
â”‚   â”‚       ON e.dept_id = d.dept_id;
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       - Supports compound conditions:
â”‚   â”‚       ```sql
â”‚   â”‚       ON a.id = b.id AND a.status = b.status
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **2. Using `USING` Clause**:
â”‚   â”‚       - Simpler syntax when **both tables share a column with the same name**.
â”‚   â”‚       - Automatically removes duplicate column from output.
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT *
â”‚   â”‚       FROM employees
â”‚   â”‚       JOIN departments
â”‚   â”‚       USING (dept_id);
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       - Equivalent to:
â”‚   â”‚       ```sql
â”‚   â”‚       ON employees.dept_id = departments.dept_id
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Differences:**
â”‚   â”‚       | Feature           | ON Clause          | USING Clause     |
â”‚   â”‚       |-------------------|--------------------|------------------|
â”‚   â”‚       | Column Names      | Can differ         | Must be identical|
â”‚   â”‚       | Output Columns    | Both shown         | One shown        |
â”‚   â”‚       | Complex Conditions| Supported          | Not supported    |
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use `USING` for **simple joins** where column names match exactly.
â”‚   â”‚       - Use `ON` when:
â”‚   â”‚         - Column names differ.
â”‚   â”‚         - You need multiple conditions.
â”‚   â”‚         - You want full control over join logic.
â”‚   â”‚
â”‚   â”‚       Example:
â”‚   â”‚       ```sql
â”‚   â”‚       -- Prefer ON for clarity in complex joins
â”‚   â”‚       JOIN orders o ON o.customer_id = c.id AND o.status = 'active'
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Note:**
â”‚   â”‚       - Both `ON` and `USING` can be used with `INNER`, `LEFT`, `RIGHT` joins.
â”‚   â”‚       - Avoid mixing styles in large queriesâ€”be consistent!
â”‚   â”‚
â”‚   â”‚
â”œâ”€â”€ Subqueries/
â”‚   â”œâ”€â”€ Scalar_Subquery/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **What is a Scalar Subquery?**
â”‚   â”‚       - A **Scalar Subquery** returns exactly **one value** (one row, one column).
â”‚   â”‚       - Itâ€™s often used where a single value is expected, like in `SELECT`, `WHERE`, or `SET`.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax Example**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, salary
â”‚   â”‚       FROM employees
â”‚   â”‚       WHERE salary > (
â”‚   â”‚           SELECT AVG(salary) FROM employees
â”‚   â”‚       );
â”‚   â”‚       ```
â”‚   â”‚       - This query fetches employees earning **above average salary**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **Visualization**:
â”‚   â”‚       1ï¸âƒ£ Inner Query:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT AVG(salary) FROM employees;
â”‚   â”‚       -- Returns: 55000
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       2ï¸âƒ£ Outer Query becomes:
â”‚   â”‚       ```sql
â”‚   â”‚       WHERE salary > 55000
â”‚   â”‚       ```
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Important Notes:**
â”‚   â”‚       - The subquery **must return exactly one value**.
â”‚   â”‚       - If it returns more than one row â†’ MySQL error:
â”‚   â”‚         ```
â”‚   â”‚         Error: Subquery returns more than 1 row
â”‚   â”‚         ```
â”‚   â”‚
â”‚   â”‚       - Use `LIMIT 1` if necessary to enforce single-row return.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use Scalar Subqueries for dynamic thresholds, calculations, or lookup values.
â”‚   â”‚       - Ensure inner queries are efficient â€” they may execute per row depending on context.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Example in SELECT Clause**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name,
â”‚   â”‚              (SELECT dept_name FROM departments d WHERE d.dept_id = e.dept_id) AS department
â”‚   â”‚       FROM employees e;
â”‚   â”‚       ```
â”‚   â”‚       - Here, the subquery dynamically fetches department names.
â”‚   â”‚
â”‚   â”‚
â”‚   â”œâ”€â”€ Correlated_Subquery/
â”‚   â”‚   â””â”€â”€ Explanation:
â”‚   â”‚       ðŸ”¹ **What is a Correlated Subquery?**
â”‚   â”‚       - A **Correlated Subquery** references columns from the **outer query**.
â”‚   â”‚       - It is **executed once per row** of the outer query.
â”‚   â”‚       - Used for row-by-row comparisons.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Œ **Syntax Example**:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT name, salary
â”‚   â”‚       FROM employees e
â”‚   â”‚       WHERE salary > (
â”‚   â”‚           SELECT AVG(salary)
â”‚   â”‚           FROM employees
â”‚   â”‚           WHERE dept_id = e.dept_id
â”‚   â”‚       );
â”‚   â”‚       ```
â”‚   â”‚       - This returns employees earning **above the average salary of their own department**.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸ“Š **How It Works**:
â”‚   â”‚       - For **each employee row**, the subquery calculates the departmentâ€™s average salary.
â”‚   â”‚       - Then compares the current employeeâ€™s salary to that value.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       ðŸš¨ **Performance Warning:**
â”‚   â”‚       - Correlated subqueries can be **slow** on large datasets because the inner query runs per outer row.
â”‚   â”‚       - Often better replaced by a `JOIN` with precomputed aggregates.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âœ… **Best Practices:**
â”‚   â”‚       - Use correlated subqueries for:
â”‚   â”‚         - Existence checks.
â”‚   â”‚         - Complex conditions that are hard to express with joins.
â”‚   â”‚
â”‚   â”‚       - Where possible, refactor like this:
â”‚   â”‚       ```sql
â”‚   â”‚       SELECT e.name, e.salary
â”‚   â”‚       FROM employees e
â”‚   â”‚       JOIN (
â”‚   â”‚           SELECT dept_id, AVG(salary) AS avg_sal
â”‚   â”‚           FROM employees
â”‚   â”‚           GROUP BY dept_id
â”‚   â”‚       ) d_avg
â”‚   â”‚       ON e.dept_id = d_avg.dept_id
â”‚   â”‚       WHERE e.salary > d_avg.avg_sal;
â”‚   â”‚       ```
â”‚   â”‚       - This avoids repetitive subquery execution.
â”‚   â”‚
â”‚   â”‚       ---
â”‚   â”‚       âš¡ **Use Cases:**
â”‚   â”‚       - "Find employees who earn more than anyone in department X."
â”‚   â”‚       - "Select products priced above the category average."
â”‚   â”‚
â”‚   â”‚
